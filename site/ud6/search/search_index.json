{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inici","text":""},{"location":"#resultats-daprenentatge","title":"Resultats d'aprenentatge","text":"<ul> <li>RA4. Optimitza codi emprant les eines disponibles en l'entorn de desenvolupament.</li> </ul>"},{"location":"#criteris-davaluacio","title":"Criteris d'avaluaci\u00f3","text":"<ul> <li>RA4.a) S'han identificat els patrons de refactoritzaci\u00f3 m\u00e9s usuals.</li> <li>RA4.b) S'han elaborat les proves associades a la refactoritzaci\u00f3.</li> <li>RA4.e) S'han aplicat patrons de refactoritzaci\u00f3 amb les eines que proporciona l'entorn de desenvolupament.</li> </ul> <p>Comencem!</p>"},{"location":"1.introduccio/","title":"1. Introducci\u00f3","text":""},{"location":"1.introduccio/#1-introduccio-a-la-unitat","title":"1. Introducci\u00f3 a la Unitat","text":"<p>La qualitat del codi \u00e9s un factor fonamental en el desenvolupament de programari. Una bon disseny i una bona qualitat del programari ens permet que el codi siga m\u00e9s f\u00e0cil de mantenir, que es puga reutilitzar f\u00e0cilment, i que es puga escalar (incorporar noves funcionalitats), facilitant aix\u00ed el treball en equip i reduint la probabilitat d\u2019errors. Aquesta unitat es centra en tres conceptes que ens ajudaran a millorar la nostra manera de programar:</p> <ul> <li>La refactoritzaci\u00f3, o proc\u00e9s d\u2019optimitzaci\u00f3 del codi sense alterar-ne el comportament.</li> <li>Els principis SOLID, un conjunt de bones pr\u00e0ctiques per al desenvolupament de programari orientat a objectes.</li> <li>Els patrons de disseny, solucions generals i reutilitzables per a problemes comuns en el desenvolupament de programari.</li> </ul>"},{"location":"1.introduccio/#necessitat-de-la-refactoritzacio","title":"Necessitat de la refactoritzaci\u00f3","text":"<p>A mesura que un projecte de programari creix, el codi pot tornar-se complex i dif\u00edcil de gestionar. \u00c9s normal que un desenvolupador, en les primeres fases d'un projecte, prioritze la funcionalitat sobre l\u2019arquitectura. No obstant aix\u00f2, si no es fa una revisi\u00f3 posterior del codi, aquest pot acabar sent dif\u00edcil de mantenir, amb acoblament excessiu, baixa cohesi\u00f3 i redund\u00e0ncia.</p> <p>La refactoritzaci\u00f3 \u00e9s el proc\u00e9s mitjan\u00e7ant el qual millorem l'organitzaci\u00f3 del codi sense alterar-ne el comportament extern. Alguns dels seus avantatges s\u00f3n:</p> <ul> <li>Millora la llegibilitat i mantenibilitat del codi.</li> <li>Evita la degradaci\u00f3 del codi (code rot) i facilita l\u2019escalabilitat del projecte.</li> <li>Redueix la duplicaci\u00f3 i ajuda a aplicar bones pr\u00e0ctiques de programaci\u00f3.</li> <li>Permet detectar i corregir errors abans que es convertisquen en problemes majors.</li> </ul> <p>Com a bons desenvolupadors, hem de ser capa\u00e7os de detectar quan una porci\u00f3 de codi necessita refactoritzaci\u00f3 i aplicar t\u00e8cniques adequades per millorar-la. \u00c9s ac\u00ed on els patrons de disseny poden jugar un paper fonamental.</p>"},{"location":"1.introduccio/#que-son-els-patrons-de-disseny","title":"Qu\u00e8 s\u00f3n els patrons de disseny?","text":"<p>Els patrons de disseny s\u00f3n solucions provades per a problemes recurrents en el desenvolupament de programari. No es tracta de fragments de codi espec\u00edfics, sin\u00f3 de conceptes o estructures que podem adaptar a diferents situacions. Els patrons ens permeten escriure codi m\u00e9s clar, modular i f\u00e0cil de mantenir.</p> <p>L'\u00fas de patrons de disseny ens aporta els seg\u00fcents beneficis:</p> <ul> <li>Fomenten un baix acoblament i una alta cohesi\u00f3.  </li> <li>Milloren la reusabilitat i la flexibilitat del codi.  </li> <li>Faciliten la comunicaci\u00f3 entre desenvolupadors mitjan\u00e7ant un llenguatge com\u00fa.  </li> <li>Redueixen la complexitat en la resoluci\u00f3 de problemes habituals.</li> </ul> <p>Un exemple cl\u00e0ssic de patr\u00f3 de disseny \u00e9s el Factory Method, que ajuda a crear objectes d'una manera flexible, evitant depend\u00e8ncies directes entre classes. M\u00e9s avant veurem aquest i molts altres patrons amb exemples concrets en Java i JavaScript.</p> <p>Els patrons de disseny es poden classificar en tres grans categories:</p> <ol> <li>Patrons creacionals: Faciliten la creaci\u00f3 d'objectes de manera flexible (Factory, Singleton, Builder\u2026).</li> <li>Patrons estructurals: Defineixen com s\u2019organitzen les estructures de dades i les relacions entre objectes (Adapter, Decorator, Composite\u2026).</li> <li>Patrons de comportament: Se centren en la comunicaci\u00f3 entre objectes i la distribuci\u00f3 de responsabilitats (Observer, Strategy, Command\u2026).</li> </ol>"},{"location":"1.introduccio/#relacio-entre-refactoritzacio-i-patrons-de-disseny","title":"Relaci\u00f3 entre refactoritzaci\u00f3 i patrons de disseny","text":"<p>Els patrons de disseny s\u00f3n de gran utilitat el proc\u00e9s de refactoritzaci\u00f3. Quan trobem codi duplicat, massa depenent d'altres classes o dif\u00edcil d\u2019entendre, podem aplicar patrons per reestructurar-lo i fer-lo m\u00e9s modular.</p> <p>Per exemple, si un fragment de codi cont\u00e9 m\u00faltiples condicions (<code>if</code>-<code>else</code>), podr\u00edem aplicar el patr\u00f3 Strategy per substituir-les per diferents implementacions encapsulades en classes separades.</p> <p>D'altra banda, si un m\u00e8tode ha de crear inst\u00e0ncies de moltes classes diferents, podem utilitzar Factory Method o Abstract Factory per desacoblar la creaci\u00f3 d\u2019objectes i fer el codi m\u00e9s flexible als canvis.</p> <p>Ara que hem introdu\u00eft la refactoritzaci\u00f3 i els patrons de disseny, passem a veure els principis SOLID amb m\u00e9s detall i com aquests ens ajuden a escriure codi m\u00e9s net i estructurat.</p>"},{"location":"2.principis_solid/","title":"2. Principis SOLID","text":""},{"location":"2.principis_solid/#principis-solid","title":"Principis SOLID","text":""},{"location":"2.principis_solid/#acoblament-i-cohesio","title":"Acoblament i cohesi\u00f3","text":"<p>Quan dissenyem programari, \u00e9s fonamental que els components siguen modulars, reutilitzables i f\u00e0cils de mantenir. Per aconseguir-ho, hem de prestar especial atenci\u00f3 a dos conceptes clau:</p>"},{"location":"2.principis_solid/#acoblament","title":"Acoblament","text":"<p>L\u2019acoblament (coupling) es refereix al grau de depend\u00e8ncia entre diferents m\u00f2duls, classes o components del sistema.</p> <ul> <li>Acoblament alt: Podem dir que existeix un alt acoblament:</li> <li>Quan un canvi en una classe obliga a modificar moltes altres.</li> <li> <p>Quan les classes tenen moltes depend\u00e8ncies entre elles.</p> <p>L'acoblament alt dificulta la reutilitzaci\u00f3 i mantenibilitat del codi.</p> </li> <li> <p>Acoblament baix(ideal): Podem dir que hi ha un acoblament baix:</p> </li> <li>Quan les classes tenen depend\u00e8ncies m\u00ednimes entre si.</li> <li>Quan cada classe se centra en una tasca espec\u00edfica.</li> </ul> <p>L'acoblament baix permet modificar una part del sistema sense afectar la resta.</p>"},{"location":"2.principis_solid/#exemple-de-codi-java-amb-alt-acoblament-incorrecte","title":"Exemple de codi Java amb alt acoblament (incorrecte)","text":"<p>Definim les classe <code>Database</code> i <code>UserService</code> de la seg\u00fcent manera:</p> <pre><code>class Database {\n    public void connect() {\n        System.out.println(\"Connecting to database...\");\n    }\n}\n\nclass UserService {\n    private Database db = new Database(); // Depend\u00e8ncia directa\n\n    public void getUser() {\n        db.connect();\n        System.out.println(\"Fetching user...\");\n    }\n}\n</code></pre> <p>Problema: La classe <code>UserService</code> dep\u00e8n directament de <code>Database</code>. Si volem canviar la implementaci\u00f3 de la base de dades, haurem de modificar el codi de <code>UserService</code>.</p> <p>Soluci\u00f3 mitjan\u00e7ant acoblament baix (injecci\u00f3 de depend\u00e8ncies):</p> <pre><code>class Database {\n    public void connect() {\n        System.out.println(\"Connecting to database...\");\n    }\n}\n\nclass UserService {\n    private Database db;\n\n    public UserService(Database db) { // Depend\u00e8ncia injectada\n        this.db = db;\n    }\n\n    public void getUser() {\n        db.connect();\n        System.out.println(\"Fetching user...\");\n    }\n}\n\n// \u00das:\nDatabase db = new Database();\nUserService userService = new UserService(db);\n</code></pre> <p>Avantatge: Ara podem substituir <code>Database</code> per una altra implementaci\u00f3 sense modificar <code>UserService</code>.</p> <p>Injecci\u00f3 de depend\u00e8ncies</p> <p>La injecci\u00f3 de depend\u00e8ncies (Dependency Injection, DI) \u00e9s un patr\u00f3 de disseny que consisteix a proporcionar les depend\u00e8ncies d\u2019una classe des de fora, en lloc que la pr\u00f2pia classe cree les seues inst\u00e0ncies internament.</p>"},{"location":"2.principis_solid/#cohesio","title":"Cohesi\u00f3","text":"<p>La cohesi\u00f3 (cohesion) mesura com de ben agrupades estan les responsabilitats dins d'una classe o m\u00f2dul.</p> <p>Un codi presenta una cohesi\u00f3 baixa quan una classe fa moltes coses diferents, la qual cosa dificulta la llegibilitat i la reutilitzaci\u00f3.  </p> <p>\u00c9s convenient tindre un codi que presenta una cohesi\u00f3 alta, \u00e9s a dir, que una classe o m\u00f2dul tinga una responsabilitat clara i ben definida, de manera que facilite la modularitat i el manteniment.</p>"},{"location":"2.principis_solid/#exemple-de-codi-amb-cohesio-baixa-incorrecte","title":"Exemple de codi amb cohesi\u00f3 baixa (incorrecte)","text":"<p>Veiem la seg\u00fcent definici\u00f3 de classe en Java:</p> <pre><code>class ReportGenerator {\n    public void generateReport() {\n        System.out.println(\"Generating report...\");\n    }\n\n    public void sendEmail() {\n        System.out.println(\"Sending report via email...\");\n    }\n\n    public void saveToDatabase() {\n        System.out.println(\"Saving report to database...\");\n    }\n}\n</code></pre> <p>Problema: Aquesta classe <code>ReportGenerator</code> t\u00e9 massa responsabilitats, no relacionades entre s\u00ed (crear informes, enviar correus i guardar dades).</p> <p>Soluci\u00f3 millorada amb cohesi\u00f3 alta:</p> <pre><code>class ReportGenerator {\n    public void generateReport() {\n        System.out.println(\"Generating report...\");\n    }\n}\n\nclass EmailService {\n    public void sendEmail() {\n        System.out.println(\"Sending email...\");\n    }\n}\n\nclass DatabaseService {\n    public void saveToDatabase() {\n        System.out.println(\"Saving to database...\");\n    }\n}\n</code></pre> <p>Amb aix\u00f2 aconseguim ara que cada classe tinga una \u00fanica responsabilitat, produint, a m\u00e9s,  un codi m\u00e9s modular i mantenible.</p>"},{"location":"2.principis_solid/#cohesio-i-acoblament-al-just-eat-pizza","title":"Cohesi\u00f3 i acoblament al Just Eat Pizza","text":"<p>Retornem a l'exemple de la pizzeria de la unitat anterior. Recordem que disposem d'una API que retorna una llista de pizzes en format JSON. Suposem ara que el nostre m\u00e8tode <code>getAllPizzes()</code> invoca directament a aquesta API i processa la resposta directament com un JSON.</p> <pre><code>class PizzaService {\n    async getAllPizzes() {\n        const response = await fetch('https://pizza-rest-server-production.up.railway.app/api/pizzeria/pizzes');\n        const jsonData = await response.json();\n        return jsonData; // Retorna directament el JSON\n    }\n}\n\n// \u00das:\nconst service = new PizzaService();\nservice.getAllPizzes().then(data =&gt; console.log(data));\n</code></pre> <p>Quin problema presenta aquesta situaci\u00f3?</p> <ul> <li>Si l'API canvia i ara retornara XML en lloc de JSON, haurem de modificar el nostre codi per adaptar-lo.</li> <li>El codi dependria directament del format de representaci\u00f3 de les dades (JSON), la qual cosa provoca un acoblament fort.</li> <li>Aix\u00f2 afecta la reusabilitat i mantenibilitat, ja que qualsevol canvi en la API requereix modificacions en el codi.</li> </ul> <p>Quina soluci\u00f3 podem proposar per reduir-ne l'acoblament?</p> <p>Per millorar aquest mal disseny, es crea una classe <code>Pizza</code> que represente una pizza com a objecte independentment del format de la resposta de l\u2019API (tal i com est\u00e0 fet a l'exemple). Aix\u00ed, si la API canvia el seu format, nom\u00e9s haurem de modificar el parser (la part que transforma o parseja un format a altre), per\u00f2 el nostre servei continuar\u00e0 treballant amb objectes <code>Pizza</code>.</p> <pre><code>export class Pizza extends Producte{\n    constructor({id, nom, desc, vegetariana, alergens, img, preu}){\n        // Propietats de Producte\n        super({id, nom, img, preu})\n\n        // Propietats addicionals de Pizza\n        this.desc=desc;\n        this.vegetariana=vegetariana;\n        this.alergens=alergens;\n    }\n}\n\n\n\n// Classe per processar diferents formats de resposta\nclass PizzaParser {\n    static fromJson(jsonData) {\n        return jsonData.map(pizza =&gt; \n            new Pizza(pizza)\n        );\n    }\n\n    static fromXml(xmlData) {\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(xmlData, \"text/xml\");\n        const pizzas = [...xmlDoc.getElementsByTagName(\"pizza\")];\n\n        return pizzas.map(pizza =&gt; \n            new Pizza(\n                pizza.getElementsByTagName(\"id\")[0].textContent,\n                pizza.getElementsByTagName(\"nom\")[0].textContent,\n                pizza.getElementsByTagName(\"desc\")[0].textContent,\n                ...\n            )\n        );\n    }\n}\n\n// Servei de pizzes que usa el parser adequat\nclass PizzaService {\n    async getAllPizzes(format = 'json') {\n        const response = await fetch(`https://.../pizzes?format=${format}`);\n        const data = await response.text();\n\n        return format === 'json' \n            ? PizzaParser.fromJson(JSON.parse(data)) \n            : PizzaParser.fromXml(data);\n    }\n}\n\n// \u00das:\nconst service = new PizzaService();\nservice.getAllPizzes('json').then(pizzes =&gt; console.log(pizzes));\nservice.getAllPizzes('xml').then(pizzes =&gt; console.log(pizzes));\n</code></pre> <p>Amb aquest codi aconseguim reduir l'acoblament, ja que <code>PizzaService</code> no dep\u00e8n directament del format de l'API, sin\u00f3 d\u2019una abstracci\u00f3 (<code>PizzaParser</code>). </p> <p>A m\u00e9s, hem aconseguit una alta cohesi\u00f3 al separar la l\u00f2gica de conversi\u00f3 (<code>PizzaParser</code>) de la l\u00f2gica de servei (<code>PizzaService</code>).</p> <p>Per altra banda, tamb\u00e9 hem generat un codi m\u00e9s mantenible, ja que si ara l'API afegira un nou format (per exemple, CSV), nom\u00e9s caldria afegir un nou m\u00e8tode a <code>PizzaParser</code> sense modificar <code>PizzaService</code>.</p>"},{"location":"2.principis_solid/#principis-solid_1","title":"Principis SOLID","text":"<p>Els principis SOLID ajuden a crear un programari m\u00e9s flexible i mantenible. Aquests principis van ser definits per Robert C. Martin (Uncle Bob) i s\u00f3n fonamentals en la programaci\u00f3 orientada a objectes. Anem amb ells.</p>"},{"location":"2.principis_solid/#principi-1-s-principi-de-responsabilitat-unica-single-responsibility-principle-srp","title":"Principi 1. S - Principi de responsabilitat \u00fanica (Single Responsibility Principle - SRP)","text":"<p>Cada classe ha de tenir una \u00fanica responsabilitat i una sola ra\u00f3 per canviar. </p> <p>Si una classe fa massa coses, es torna dif\u00edcil de mantenir i modificar. Separant les responsabilitats, millorem la llegibilitat i facilitem la reutilitzaci\u00f3.</p> <ul> <li>Exemple incorrecte (classe amb m\u00faltiples responsabilitats):</li> </ul> <pre><code>class Order {\n    public void calculateTotal() { /* c\u00e0lcul de total */ }\n    public void printInvoice() { /* impressi\u00f3 de factura */ }\n    public void saveToDatabase() { /* desar en BD */ }\n}\n</code></pre> <ul> <li>Exemple Correcte (separem responsabilitats en classes diferents):</li> </ul> <pre><code>class Order {\n    public void calculateTotal() { /* c\u00e0lcul de total */ }\n}\n\nclass InvoicePrinter {\n    public void printInvoice() { /* impressi\u00f3 de factura */ }\n}\n\nclass OrderRepository {\n    public void saveToDatabase() { /* desar en BD */ }\n}\n</code></pre>"},{"location":"2.principis_solid/#principi-2-o-principi-dobert-tancat-openclosed-principle-ocp","title":"Principi 2. O - Principi d'Obert-Tancat (Open/Closed Principle - OCP)","text":"<p>Les classes han d'estar obertes a l'extensi\u00f3 per\u00f2 tancades a la modificaci\u00f3. </p> <p>Aquest principi ens indica que el codi ha de permetre afegir funcionalitats noves (obert a l'extensi\u00f3) sense haver de modificar les classes existents (tancades a la modificaci\u00f3), reduint el risc d'introduir errors en el sistema.</p> <ul> <li>Exemple incorrecte: El seg\u00fcent codi presenta una classe <code>ShapePrinter</code> que imprimeix diferents formes (<code>Rectangle</code>, <code>Circle</code>).</li> </ul> <pre><code>class Rectangle {\n    public void draw() { System.out.println(\"Dibuixant rectangle\"); }\n}\n\nclass Circle {\n    public void draw() { System.out.println(\"Dibuixant cercle\"); }\n}\n\nclass ShapePrinter {\n    public void print(Rectangle rect) { rect.draw(); }\n    public void print(Circle circ) { circ.draw(); }\n}\n</code></pre> <p>El problema que presenta aquest codi \u00e9s que, cada vegada que volem afegir una nova forma (per exemple, Triangle o Hexagon), hem de modificar <code>ShapePrinter</code>, cosa que trenca el principi d\u2019Obert-Tancat: hem de modificar la classe <code>ShapePrinter</code> per poder afegir-li noves funcionalitats, obrint-la per tant a la modificaci\u00f3 per estendre-la. Aix\u00f2 fa que la soluci\u00f3 siga dif\u00edcil d'escalar i de mantenir.</p> <ul> <li>Exemple Correcte:  Per corregir la situaci\u00f3 anterior, podem fer que <code>ShapePrinter</code> funcione amb una interf\u00edcie o classe abstracta <code>Shape</code>, de manera que qualsevol nova forma nom\u00e9s haja d\u2019implementar <code>Shape</code> i <code>ShapePrinter</code> no s'haja de modificar.</li> </ul> <pre><code>// Es defineix com a classe abstracta, per\u00f2 podria ser tamb\u00e9 una interf\u00edcie\nabstract class Shape {\n    public abstract void draw();\n}\n\nclass Rectangle extends Shape {\n    public void draw() { System.out.println(\"Dibuixant rectangle\"); }\n}\n\nclass Circle extends Shape {\n    public void draw() { System.out.println(\"Dibuixant cercle\"); }\n}\n\nclass ShapePrinter {\n    public void print(Shape shape) { shape.draw(); }\n}\n</code></pre> <p>Si ara volem crear una nova classe <code>Triangle</code>, no modificariem res de l'anterior:</p> <pre><code>class Triengle extends Shape {\n    public void draw() { System.out.println(\"Dibuixant Triangle\"); }\n}\n</code></pre>"},{"location":"2.principis_solid/#principi-3-l-principi-de-substitucio-de-liskov-liskov-substitution-principle-lsp","title":"Principi 3. L - Principi de substituci\u00f3 de Liskov (Liskov Substitution Principle - LSP)","text":"<p>Les subclasses han de poder substituir les seves superclasses sense trencar el comportament del programa. </p> <p>Si una subclasse altera el comportament esperat de la classe base, pot provocar errors inesperats en altres parts del sistema. \u00c9s a dir, si una classe A \u00e9s la superclasse d'una classe B, qualsevol inst\u00e0ncia de B ha de comportar-se com una inst\u00e0ncia de A sense trencar el codi.</p> <ul> <li>Exemple Incorrecte (una subclasse que no mant\u00e9 el comportament de la superclasse):</li> </ul> <pre><code>class Bird {\n    public void fly() { System.out.println(\"Flying\"); }\n}\n\nclass Penguin extends Bird {\n    // Els ping\u00fcins no poden volar!\n}\n</code></pre> <p>En aquest cas, la classe <code>Penguin</code> trenca el comportament de la classe base, ja que no pot tindre un m\u00e8tode <code>fly</code>.</p> <ul> <li>Correcci\u00f3: Hem de redefinim l'estructura per evitar el problema. Com que no totes les aus volen, deixem la classe Bird com a classe abstracta i creem una nova classe per a les aus que s\u00ed que volen:</li> </ul> <pre><code>abstract class Bird { }\n\nclass FlyingBird extends Bird {\n    public void fly() { System.out.println(\"Flying\"); }\n}\n\nclass Penguin extends Bird { }\n</code></pre> <p>Un exemple sobre la pizzeria</p> <p>A l'exemple de la pizzeria, quan gestionem les comandes amb llistes de productes, estem aplicant el Principi de Substituci\u00f3 de Liskov (LSP) de manera correcta, sempre que les subclasses (<code>Pizza</code>, <code>Entrant</code>, <code>Beguda</code>) puguen substituir la classe base (<code>Producte</code>) sense trencar el codi.</p> <p>Com podem vore, aquest principi est\u00e0 estretament relacionat amb el polimorfisme en la POO. El polimorfisme permet que un objecte d'una subclasse siga tractat com un objecte de la seua superclasse, cosa que encaixa perfectament amb el principi LSP.</p> <ul> <li>El polimorfisme ens permet escriure codi gen\u00e8ric i reutilitzable:</li> <li>Si una subclasse pot substituir la seva superclasse sense problemes, podem fer servir el polimorfisme per evitar el codi depenent de tipus concrets.</li> <li>Aix\u00f2 fa que el codi siga m\u00e9s flexible i extensible sense necessitat de modificar-lo.</li> <li>El principi LSP garanteix que el polimorfisme funcione correctament:</li> <li>Si una subclasse no es comporta com la superclasse esperada, el polimorfisme pot trencar-se.</li> <li>LSP assegura que, si fem servir una subclasse en lloc de la superclasse, el codi continuar\u00e0 funcionant sense modificar-se.</li> </ul>"},{"location":"2.principis_solid/#principi-4-i-principi-de-segregacio-dinterficies-interface-segregation-principle-isp","title":"Principi 4. I - Principi de segregaci\u00f3 d'interf\u00edcies (Interface Segregation Principle - ISP)","text":"<p>\u00c9s millor tenir interf\u00edcies menudes i espec\u00edfiques que una \u00fanica interf\u00edcie gran. </p> <p>Segons aquest principi, si una interf\u00edcie obliga una classe a implementar m\u00e8todes que no necessita, significa que est\u00e0 mal dissenyada. \u00c9s preferible dividir-la en interf\u00edcies m\u00e9s menudes i enfocades. Veiem-ho amb un exemple:</p> <ul> <li>Exemple Incorrecte (interf\u00edcie massa gran): La seg\u00fcent interf\u00edcie implementa els m\u00e8todes <code>work</code> i <code>eat</code>.</li> </ul> <pre><code>interface Worker {\n    void work();\n    void eat();\n}\n</code></pre> <p>Aix\u00f2 obliba a que totes les classes que la implementen, implementen ambd\u00f3s m\u00e8todes. Si tenim una classe que necessita implementar work per\u00f2 no eat, estem obligant-la a implementar els dos.</p> <ul> <li>Exemple Correcte (interf\u00edcies m\u00e9s espec\u00edfiques): Per donar soluci\u00f3, segreguem aquesta interf\u00edcie en dues:</li> </ul> <pre><code>interface Workable {\n    void work();\n}\n\ninterface Eatable {\n    void eat();\n}\n</code></pre> <p>De manera que una classe pot implementar una, altra o les dues alhora, segons les seues necessitats.</p>"},{"location":"2.principis_solid/#principi-5-d-principi-dinversio-de-dependencies-dependency-inversion-principle-dip","title":"Principi 5. D - Principi d'inversi\u00f3 de depend\u00e8ncies (Dependency Inversion Principle - DIP)**","text":"<p>Les depend\u00e8ncies han d'estar en abstraccions, no en classes concretes. </p> <p>Aquest principi significa que les classes d'alt nivell no han de dependre de les de baix nivell. En canvi, totes han de dependre d'abstraccions (interf\u00edcies o classe abstractes) per fer el codi m\u00e9s flexible i f\u00e0cil d\u2019adaptar. Veiem-ho amb un exemple:</p> <ul> <li>Problema: Violaci\u00f3 del principi DIP</li> </ul> <p>Imaginem que tenim una classe <code>ComandaService</code> que dep\u00e8n directament d\u2019una implementaci\u00f3 espec\u00edfica de <code>Database</code> per a guardar comandes en la base de dades.</p> <pre><code>class MySQLDatabase {\n    public void saveOrder(String order) {\n        System.out.println(\"Desant la comanda en MySQL: \" + order);\n    }\n}\n\nclass ComandaService {\n    private MySQLDatabase database = new MySQLDatabase(); // DEPEND\u00c8NCIA DIRECTA!\n\n    public void save(String order) {\n        database.saveOrder(order);\n    }\n}\n</code></pre> <p>Aquesta \u00e9s una mala soluci\u00f3 pels seg\u00fcents motius:</p> <ul> <li>Presenta un acoblament fort, ja que <code>ComandaService</code> dep\u00e8n directament de <code>MySQLDatabase</code>. Si volem canviar a una altra base de dades (per exemple, PostgreSQL), hem de modificar <code>ComandaService</code>.</li> <li>Presenta poca flexibilitat, ja que no podem reutilitzar <code>ComandaService</code> amb una altra implementaci\u00f3 de base de dades sense modificar el codi existent.</li> <li>Dificultat les proves: Si volem fer tests de <code>ComandaService</code>, necessitem una inst\u00e0ncia real de <code>MySQLDatabase</code>, la qual cosa complica les proves unit\u00e0ries.</li> </ul> <p>Com ajuda l'aplicaci\u00f3 del principi DIP?</p> <p>Podem resoldre aquest problema introduint una interf\u00edcie <code>Database</code>, que encapsule el comportament esperat de qualsevol base de dades. Aix\u00ed, <code>ComandaService</code> treballar\u00e0 amb la interf\u00edcie i no amb una implementaci\u00f3 concreta.</p> <pre><code>// Interf\u00edcie gen\u00e8rica per a la base de dades\ninterface Database {\n    void saveOrder(String order);\n}\n\n// Implementaci\u00f3 per a MySQL\nclass MySQLDatabase implements Database {\n    public void saveOrder(String order) {\n        System.out.println(\"Guardant la comanda en MySQL: \" + order);\n    }\n}\n\n// Implementaci\u00f3 per a PostgreSQL\nclass PostgreSQLDatabase implements Database {\n    public void saveOrder(String order) {\n        System.out.println(\"Guardant la comanda en PostgreSQL: \" + order);\n    }\n}\n\n// Ara ComandaService dep\u00e8n d'una ABSTRACCI\u00d3 (Database), no d'una implementaci\u00f3 concreta\nclass ComandaService {\n    private Database database;\n\n    public ComandaService(Database database) { // Injecci\u00f3 de depend\u00e8ncies\n        this.database = database;\n    }\n\n    public void save(String order) {\n        database.saveOrder(order);\n    }\n}\n\n// \u00das del servei amb diferents bases de dades\npublic class Main {\n    public static void main(String[] args) {\n        Database mysql = new MySQLDatabase();\n        Database postgres = new PostgreSQLDatabase();\n\n        ComandaService comanda1 = new ComandaService(mysql);\n        comanda1.save(\"Pizza 4 formatges\");\n\n        ComandaService comanda2 = new ComandaService(postgres);\n        comanda2.save(\"Pizza Barbacoa\");\n    }\n}\n</code></pre> <p>Quins beneficis aporta aquesta soluci\u00f3?</p> <ul> <li>Baix acoblament: <code>ComandaService</code> no sap ni li importa quina base de dades s\u2019est\u00e0 utilitzant.</li> <li>Flexibilitat: Podem afegir noves bases de dades (MongoDB, Firebase, etc.) sense modificar <code>ComandaService</code>.</li> <li>M\u00e9s f\u00e0cil de provar: Podem crear un <code>MockDatabase</code> per a fer proves unit\u00e0ries sense utilitzar una base de dades real.</li> </ul>"},{"location":"3.patrons/","title":"3. Introducci\u00f3 als patrons de disseny","text":""},{"location":"3.patrons/#3-patrons-de-disseny","title":"3. Patrons de Disseny","text":""},{"location":"3.patrons/#introduccio-als-patrons-de-disseny","title":"Introducci\u00f3 als patrons de disseny","text":"<p>Els patrons de disseny s\u00f3n solucions habituals a problemes recurrents que es presenten durant el desenvolupament de programari. No es tracta de fragmentes de codi predefinits, sin\u00f3 de conceptes generals que podem aplicar a diverses situacions. Aquests patrons es poden adaptar a les necessitats espec\u00edfiques de cada projecte per fer que el codi siga m\u00e9s modular, flexible i mantenible.</p> <p>En el desenvolupament de programari, al llarg del temps i l'evoluci\u00f3 dels paradigmes, els desenvolupadors s'han anat trobant amb diferents problemes, que s'han abordat de diverses formes. Com ja sabem, en programaci\u00f3, un problema pot resoldre's de moltes formes diferents, per\u00f2 sempre hi ha unes millors que altres.</p> <p>Amb el temps, s'han desenvolupat solucions elegants, eficients i de gran qualitat a aquests problemes comuns, esdevenint solucions est\u00e0ndard i donant lloc al que hui en dia coneixem com patrons de disseny.</p>"},{"location":"3.patrons/#classificacio-dels-patrons-de-disseny","title":"Classificaci\u00f3 dels patrons de disseny","text":"<p>Existeixen diferents criteris a l'hora d'establir una classificaci\u00f3 quan parlem de patron s de disseny. Segons el criteri que escollim tindrem una o altra classificaci\u00f3 dels patorons.</p> <p>En general, podem establir classificacions en funci\u00f3 del nivell d'abstracci\u00f3 o escala, de la funcionalitat, de l'objectiu, o del domini d'aplicaci\u00f3.</p> <ul> <li> <p>Patrons en funci\u00f3 del nivell d'abstracci\u00f3 o l'escala: No \u00e9s el mateix un patr\u00f3 que servisca per especificar l'arquitectura general d'una aplicaci\u00f3,que un patr\u00f3 que ens ajude a especificar com es relacionen o creen inst\u00e0ncies de classes. Per exemple, els patrons MVC (mMdel-Vista-Controlador), MVVM (Model-Vista-ViewModel), o una arquitectura client-servidor s\u00f3n patrons arquitect\u00f2nics, que ens ajudaran a entendre l'arquitectura general de l'aplicaci\u00f3. En canvi, a una escala menor, tenim per exemple el patr\u00f3 Singleton, que ens ajuda, per exemple a fer que nom\u00e9s existisca una inst\u00e0ncia d'una classe concreta en el sistema.</p> </li> <li> <p>Patrons segons la funcionalitat: Aquesta classificaci\u00f3 es basa en el tipus de problemes que resolen, segons la qual, podem distingir entre patrons de construcci\u00f3 o creacionals (resolen problemes relacionats amb la creaci\u00f3 d'objectes), estructurals (resolen problemes relacionats amb l'organitzaci\u00f3 i composici\u00f3 de les classes) i de comportament (resolen problemes relacionats amb la interacci\u00f3 entre objectes i la distribuci\u00f3 de responsabilitats). Tractarem aquests patrons en detall m\u00e9s endavant.</p> </li> <li> <p>Classificaci\u00f3 segons l'objectiu principal que busquen, ja siga per millorar el manteniment i permetre que els sistemes siguen m\u00e9s adaptables als canvis, l'efici\u00e8ncia en temps i recursos o la flexibilitat durant l'execuci\u00f3.</p> </li> <li> <p>Classificaci\u00f3 segons el domini de l'aplicaci\u00f3, o l'\u00e0rea concreta del sistema on es resol el problema. Poden tractar-se de patrons de concurr\u00e8ncia, que gestionen la sincronitzaci\u00f3 i el paral\u00b7lelisme entre m\u00faltiples fils o processos, patrons per a sistemes distribu\u00efts, o per gestionar la creaci\u00f3 d'interf\u00edcies gr\u00e0fiques.</p> </li> </ul>"},{"location":"3.patrons/#patrons-de-disseny-que-tractarem","title":"Patrons de Disseny que tractarem","text":"<p>Una vegada vistes aquestes classificacions generals, anem a centrar-nos en aquells patrons de disseny que estan m\u00e9s directament relacionats amb la creaci\u00f3 i organitzaci\u00f3 de l'arquitectura del codi, aix\u00ed com en la distribuci\u00f3 de responsabilitats entre objectes. Concretament, explorarem tres grans categories de patrons que seran d'utilitat per als nostres projectes:</p> <ol> <li> <p>Patrons Creacionals: Ens ajudaran a gestionar la creaci\u00f3 d'objectes d\u2019una manera flexible i eficient. Aix\u00f2 inclou patrons com el Factory Method i el Singleton, que resolen problemes relacionats amb la creaci\u00f3 d\u2019objectes i la manera en qu\u00e8 aquests s\u2019han de gestionar.</p> </li> <li> <p>Patrons Estructurals: Es concentraran en com organitzar i estructurar les classes i objectes dins del sistema, millorant l'efici\u00e8ncia i la reutilitzaci\u00f3 del codi. Alguns exemples serien l'Adapter o el Composite.</p> </li> <li> <p>Patrons de Comportament: Tractaran sobre la comunicaci\u00f3 i la distribuci\u00f3 de responsabilitats entre els objectes del sistema, com el patr\u00f3 Observer o el patr\u00f3 Strategy, que permeten gestionar interaccions din\u00e0miques.</p> </li> </ol> <p>Cadascun d'aquests patrons ens permetr\u00e0 afrontar problemes habituals en el disseny de programari, fent que el nostre codi siga m\u00e9s flexible, m\u00e9s f\u00e0cil de mantenir i escalable, i millorant, en definitiva, la qualitat del codi al reduir l'acoblament i augmentar la cohesi\u00f3, respectant els principis SOLID.</p>"},{"location":"4.1.patrons_creacionals/","title":"4.1. Patrons creacionals","text":""},{"location":"4.1.patrons_creacionals/#patrons-creacionals","title":"Patrons Creacionals","text":"<p>Els patrons creacionals s'encarreguen de gestionar la creaci\u00f3 d'objectes, i permeten decidir el moment i la forma en qu\u00e8 es creen aquests (en altres paraules, quan, on i com es fa el <code>new</code> per crear l'objecte).</p> <p>Aquests patrons ens asseguren sistemes m\u00e9s f\u00e0cils de manteniir i m\u00e9s escalables, ja que a\u00efllen la l\u00f2gica de creaci\u00f3 dels objectes i ens proporcionen flexibilitat per canviar la forma en qu\u00e8 es crearan els objectes.</p> <p>Refactoring Guru</p> <p>El lloc web Refactoring.guru \u00e9s tot un referent en quant a patrons de disseny, patrons de refactoritzaci\u00f3 i principis SOLID.</p> <p>En ell s'hi descriuren una gran quantitat de patrons, i podeu veure la seua implementaci\u00f3 en diversos llenguatges de programaci\u00f3.</p> <p>En aquesta unitat ens basarem en moltes de les explicacions que hi fa el lloc web, per\u00f2 all\u00ed disposes de molta m\u00e9s informaci\u00f3 per ampliar els teus coneixements.</p>"},{"location":"4.1.patrons_creacionals/#classificacio-dels-patrons-creacionals","title":"Classificaci\u00f3 dels Patrons Creacionals","text":"<p>Segons Refactoring Guru, els principals patrons creacionals s\u00f3n:</p> <ol> <li>Factory Method: Permet crear objectes d'una classe sense especificar-ne la classe exacta.</li> <li>Abstract Factory: Proporciona una interf\u00edcie per crear fam\u00edlies d'objectes sense especificar les classes concretes.</li> <li>Singleton: Garanteix que nom\u00e9s existisca una inst\u00e0ncia d\u2019una classe en tota l'aplicaci\u00f3.</li> <li>Builder: Permet crear objectes complexos pas a pas.</li> <li>Prototype: Crea nous objectes clonant un prototip.</li> </ol> <p>Anem a veure alguns d'aquests exemples, per\u00f2 recordeu que teniu m\u00e9s informaci\u00f3 a Refactoring.guru</p>"},{"location":"4.1.patrons_creacionals/#1-factory-method","title":"1. Factory Method","text":"<p>El Factory Method \u00e9s un patr\u00f3 que permet crear objectes de manera flexible i sense especificar la classe exacta de l'objecte a crear. Aquest patr\u00f3 defineix una interf\u00edcie per crear un objecte, per\u00f2 deixa que les subclasses decidisquen quina classe instanciar.</p>"},{"location":"4.1.patrons_creacionals/#exemple-de-codi-enviament-de-comandes","title":"Exemple de codi: Enviament de comandes","text":"<p>Imaginem que en el sistema de la pizzeria, quan el client fa una comanda, pot triar entre recollir-la a la pizzeria o entre enviament a domicili. Cada tipus d'enviament t\u00e9 diferents caracter\u00edstiques i maneres de gestionar-se.</p> <p>En aquest cas, ens centrem en el desenvolupament en la part del servidor, que estaria implementat, per exemple amb Java.</p> <p>El patr\u00f3 Factory Method ens permetria crear el servei d'enviament adequat sense haver de saber exactament quina implementaci\u00f3 concreta utilitzar (recollida o enviament a domicili). Aix\u00f2 facilita l'extensi\u00f3 del sistema per afegir m\u00e9s opcions d'enviament m\u00e9s endavant (per exemple, enviament expr\u00e9s, lliurament amb dron, etc.), tot amb un codi net i mantenible.</p>"},{"location":"4.1.patrons_creacionals/#com-podriem-aplicar-factory-method","title":"Com podr\u00edem aplicar Factory Method?","text":"<p>Cada tipus d\u2019enviament podria ser tractat com un tipus d\u2019objecte diferent, i la f\u00e0brica decidiria quin tipus crear en funci\u00f3 de la selecci\u00f3 del client.</p> <p>Per a aix\u00f2, hem de realitzar les seg\u00fcents tasques:</p> <ol> <li> <p>Crear interf\u00edcie (classe abstracta) com\u00fa: Tots els tipus d\u2019enviament heretarien d\u2019una classe base comuna <code>Enviament</code> amb m\u00e8todes comuns, com per exemple <code>calcularCost()</code> i <code>processar()</code>.</p> </li> <li> <p>Crear f\u00e0briques concretes: Tenim una f\u00e0brica abstracta <code>EnviamentFactory</code>, i les f\u00e0briques concretes (<code>EnviamentDomiciliFactory</code> i <code>RecollidaFactory</code>) crearien els objectes espec\u00edfics per a cada tipus d'enviament.</p> </li> </ol> <p>Veiem com quedaria el codi de manera simplificada:</p> <pre><code>// Interf\u00edcie comuna per a tots els tipus d'enviament\nabstract class Enviament {\n    // Suposem que ja tenim la classe Producte definida pr\u00e8viament\n    protected List&lt;Producte&gt; productes = new ArrayList&lt;&gt;();\n    public abstract void processar();\n    public abstract double calcularCost();\n}\n\n// Tipus d'enviament: A domicili\nclass EnviamentDomicili extends Enviament {\n    private double preu;\n\n    public EnviamentDomicili() {\n        // Preu fix inicial per a l'enviament a domicili\n        // (l'enviament a domicili t\u00e9 un cost de 3\u20ac)\n        this.preu = 3.00; \n    }\n\n    @Override\n    public void processar() {\n        System.out.println(\"Enviant la comanda a domicili...\");\n    }\n\n    @Override\n    public double calcularCost() {\n        double totalProductes = 0;\n        for (Producte p : productes) {\n            totalProductes += p.getPreu();\n        }\n        return totalProductes + this.preu;  // Cost dels productes + cost d'enviament\n    }\n    }\n}\n\n// Tipus d'enviament: Recollida en tenda\nclass RecollidaTenda extends Enviament {\n    @Override\n    public void processar() {\n        System.out.println(\"La comanda est\u00e0 llesta per a ser recollida a la tenda.\");\n    }\n\n    @Override\n    public double calcularCost() {\n        double totalProductes = 0;\n        for (Producte p : productes) {\n            totalProductes += p.getPreu();\n        }\n        return totalProductes;  // Nom\u00e9s el cost dels productes (sense cost d'enviament)\n    }\n}\n\n/*\nAra definim les diferents f\u00e0briques per crear els objectes\n*/\n\n// F\u00e0brica abstracta per crear els enviaments \nabstract class EnviamentFactory {\n    public abstract Enviament createEnviament();\n}\n\n// F\u00e0brica per a enviament a domicili\nclass EnviamentDomiciliFactory extends EnviamentFactory {\n    @Override\n    public Enviament createEnviament() {\n        return new EnviamentDomicili();\n    }\n}\n\n// F\u00e0brica per a recollida en tenda\nclass RecollidaFactory extends EnviamentFactory {\n    @Override\n    public Enviament createEnviament() {\n        return new RecollidaTenda();\n    }\n}\n</code></pre> <p>Qu\u00e8 podem extreure del codi anterior?</p> <ul> <li>Enviament \u00e9s la classe base amb dos m\u00e8todes: <code>processar()</code>, per iniciar el proc\u00e9s d'enviament o recollids, i <code>calcularCost()</code>,per calcular el cost de l'enviament.</li> <li>Les classes concretes <code>EnviamentDomicili</code> i <code>RecollidaTenda</code> implementen aquests m\u00e8todes de manera diferent, seguint el patr\u00f3 Factory Method.</li> <li>Les f\u00e0briques <code>EnviamentDomiciliFactory</code> i <code>RecollidaFactory</code> decideixen quina classe concreta crear, depenent de la selecci\u00f3 de l'usuari.</li> </ul> <p>Una vegada definit aix\u00f3, la classe principal utilitzaria aquestes f\u00e0briques de la forma seg\u00fcent:</p> <pre><code>// Selecci\u00f3 del tipus d'enviament, per exemple, enviament a domicili\n// Observeu que definim factory com a la classe base per a les f\u00e0briques (EnviamentFactory)\n// per\u00f2 el que creem \u00e9s una subclasse d'aquesta (EnviamentDomiciliFactory)\nEnviamentFactory factory = new EnviamentDomiciliFactory();\n\n// Ara creem enviament, definint-la com a la classe base,\n// Per\u00f2 la f\u00e0brica ens retornar\u00e0 la subclasse (concreta) corresponent\nEnviament enviament = factory.createEnviament();\n\n// Ara podem processar la comanda (aix\u00f2 seria independent del tipus)\nenviament.processar();  \n\n// I calcular el seu cost\nSystem.out.println(\"Cost total de la comanda: \" + enviament.calcularCost() + \"\u20ac\");\n\n\n// Per a una recollida en tenda far\u00edem\nfactory = new RecollidaFactory();\nEnviament recollida = factory.createEnviament();\nrecollida.processar();  // Processem la comanda de recollida\nSystem.out.println(\"Cost total de la comanda: \" + enviament.calcularCost() + \"\u20ac\");\n</code></pre> <p>Exemple complet</p> <p>Disposeu de l'exemple complet al fitxer ExempleFactory.java, del paquet <code>exemples.factory</code>.</p> <p>Pots compilar-lo amb <code>javac</code> i executar-lo amb <code>java</code>?</p>"},{"location":"4.1.patrons_creacionals/#diagrama-uml-per-visualitzar-la-solucio","title":"Diagrama UML per visualitzar la soluci\u00f3","text":"<p>Els patrons de disseny solen ser m\u00e9s senzills d'entendre quan els acompanyem dels corresponents diagrames de classes UML, on veiem gr\u00e0ficament l relaci\u00f3 entre les diferents classes.</p> <p>Al lloc web de Refactoring Guru sobre el patr\u00f3 Factory Method, podem trobar els diagrames de classes de forma conceptual. Anem a veure ara el diagrama de classes aplicat al nostre exemple:</p> <p></p> <p>El m\u00e8tode <code>createEviament</code> \u00e9s un m\u00e8tode abstracte en <code>EnviamentFactory</code>, i les subclasses concretes (<code>EnviamentDomiciliFactory</code> i <code>RecollidaFactory</code>) implementen aquest m\u00e8tode per crear els tipus d'enviament concrets.</p> <p>Aix\u00f2 ens permetr\u00e0 afegir m\u00e9s tipus d'enviament sense haver de modificar el codi de la f\u00e0brica ni la l\u00f2gica principal de l'aplicaci\u00f3, nom\u00e9s afegint noves f\u00e0briques.</p> <p>Pensem un poc...</p> <ol> <li>Examina a la web de Refactoring Guru aquet patr\u00f3. All\u00ed s'indica de forma detallada i per passos l'estructura d'aquest patr\u00f3. Tracta d'identificar l'estructura que es presenta i els passos que s'hi descriuren, i descriu de la mateixa manera el diagrama presentat Per als Enviaments.</li> <li>Seguint l'anterior, \u00bfCom podr\u00edem afegir un nou tipus d'enviament EnviamentPerDron?</li> <li>Revisa els principis SOLID, i indica quin principi estem refor\u00e7ant amb aquest patr\u00f3.</li> </ol>"},{"location":"4.1.patrons_creacionals/#2-singleton","title":"2. Singleton","text":"<p>El patr\u00f3 Singleton assegura que nom\u00e9s hi haur\u00e0 una inst\u00e0ncia d\u2019una classe durant tota l'execuci\u00f3 del programa i proporciona un punt global d'acc\u00e9s a aquesta mateixa inst\u00e0ncia.</p> <p>Aix\u00f2 ens \u00e9s de gran utilitat en tots aquells casos que necessitem tindre, per exemple una inst\u00e0ncia \u00fanica d'una connexi\u00f3 a una base de dades, o un acc\u00e9s \u00fanic a un Repositori d'informaci\u00f3.</p> <p>Podem veure el funcionament en el seg\u00fcent diagrama de classes:</p> <p></p>"},{"location":"4.1.patrons_creacionals/#exemple","title":"Exemple","text":"<p>Suposem que volem gestionar la connexi\u00f3 a la base de dades de manera que nom\u00e9s hi haja una inst\u00e0ncia de la connexi\u00f3 durant tota l'aplicaci\u00f3.</p> <pre><code>class DatabaseConnection {\n    // Definim una inst\u00e0ncia de la pr\u00f2pia classe de manera interna\n    private static DatabaseConnection instance;\n\n    private DatabaseConnection() {\n        // Constructor privat per evitar la creaci\u00f3 d'inst\u00e0ncies externes\n        // Com que \u00e9s privat... ning\u00fa por fer new des de fora!\n    }\n\n    public static DatabaseConnection getInstance() {\n        // Creem un m\u00e8tode est\u00e0tic espec\u00edfic per obtenir la \n        // inst\u00e0ncia de la classe\n\n\n        if (instance == null) {\n            // Si la inst\u00e0ncia no existeix, es crea.\n            // Aquesta \u00e9s \u00e1 \u00fanica vegada que es far\u00e0 new.\n            instance = new DatabaseConnection();\n        }\n\n        // I retornem la inst\u00e0ncia\n        return instance;\n    }\n\n    public void connect() {\n        System.out.println(\"Conectant a la base de dades...\");\n    }\n}\n</code></pre> <p>Veiem qu\u00e8 hem fet:</p> <ul> <li>Inst\u00e0ncia \u00fanica: La classe <code>DatabaseConnection</code> inclou una refer\u00e8ncia a ella mateixa, que ser\u00e0 \u00fanica, i nom\u00e9s ser\u00e0 instanciada una vegda mitjan\u00e7ant el m\u00e8tode est\u00e0tic <code>getInstance()</code>.</li> <li> <ul> <li>Constructor privat i m\u00e8todes est\u00e0tics: El fet que el constructor siga privat implica que ning\u00fa, des de fora podr\u00e0 crear inst\u00e0acies. La classe sofereix el m\u00e8tode est\u00e0tic <code>getInstance()</code> per retornar, de forma controlada l'acc\u00e9s a la classe.</li> </ul> </li> <li>El m\u00e8tode est\u00e0tic <code>getInstance()</code> ens assegura que nom\u00e9s es crea una vegada la inst\u00e0ncia de la classe. Quan s'invoca, aquest comprova si la refer\u00e8ncia \u00e9s nul\u00b7la. Si la inst\u00e0ncia no \u00e9s nul\u00b7la, la recorna, i en cas que siga nul\u00b7la, la crea (i despr\u00e9s la retorna).</li> <li>Acc\u00e9s global: Aix\u00f2 garanteix que en qualsevol punt del codi, s'accedeixi sempre a la mateixa inst\u00e0ncia de la connexi\u00f3 a la base de dades.</li> </ul>"},{"location":"4.2.patrons_comportament/","title":"4.2.patrons comportament","text":""},{"location":"4.2.patrons_comportament/#patrons-de-comportament","title":"Patrons de comportament","text":"<p>Els patrons de comportament s\u2019ocupen de com els objectes interactuen entre ells i com es distribueixen les responsabilitats dins del sistema. Aquests patrons s\u00f3n \u00fatils per gestionar la comunicaci\u00f3 entre objectes, la distribuci\u00f3 de responsabilitats i l\u2019organitzaci\u00f3 d\u2019algoritmes dins del sistema.</p> <p>Existeixen diversos patrons de comportament. A Refactoring Guru es comenten els patrons:</p> <ul> <li>Chain of Responsibility</li> <li>Command</li> <li>Iterator</li> <li>Mediator</li> <li>Memento</li> <li>Observer</li> <li>State</li> <li>Strategy</li> <li>Template Method</li> <li>Visitor</li> </ul> <p>Et sona algun d'aquests?</p> <p>Us sona el nom d'algun d'aquests patrons?</p> <p>Consulteu-ne la descripcio al lloc web de Refactoring Guru i comproveu-ho.</p>"},{"location":"4.2.patrons_comportament/#el-patro-observer","title":"El patr\u00f3 Observer","text":"<p>Un dels patrons de comportament bastant interessant, \u00e9s el patr\u00f3 Observer. Aquest patr\u00f3 permet que un objecte notifique a altres objectes quan el seu estat canvia. Aquest patr\u00f3 \u00e9s \u00fatil quan un canvi d'estat en un objecte ha de reflectir-se en altres objectes, per\u00f2 sense que aquests estiguen fortament acoblats.</p> <p>Un cas t\u00edpic d'aquest patr\u00f3 s\u00f3n els sistemes de notificaci\u00f3 a diversos components quan es produeix un canvi. Un exemple real que es planteja a Refactoring Guru seria un sistema de gesti\u00f3 de not\u00edcies on els usuaris subscriptors reben actualitzacions quan hi ha una nova not\u00edcia o producte.</p>"},{"location":"4.2.patrons_comportament/#elements-i-funcionament","title":"Elements i funcionament","text":"<p>L'objecte que t\u00e9 un estat que volem compartir sol dir-se notificador o publicador. La resta d'objectes que volen con\u00e9ixer els canvis d'estat s'anomenen subscriptors.</p> <p>Quan utilitzem el patr\u00f3 Observer, se'ns suggereix afegir un mecanisme de subscripci\u00f3 a la classe notificador, per a que altres objectes individuals es puguen subscriure o cancel\u00b7lar les subscripcions al flux d'esdeveniments que provenen del notificador.</p> <p>Per fer aix\u00f2:</p> <ol> <li>El notificador mant\u00e9 una llista per guardar totes les refer\u00e8ncies als objectes subscriptors.</li> <li>El notificador cont\u00e9 diversos m\u00e8todes p\u00fablics que permeten que altres components se subscriguen o cancel\u00b7len les subscripcions, de maner aque s'afigen o eliminen de la llista, respectivament.</li> <li>Quan cal enviar una notificaci\u00f3, es recorre la llist, i es notifica de manera individual cada component de la llista de subscripts.</li> </ol> <p>Perfecte! Aqu\u00ed tens la continuaci\u00f3 de l'apartat que comentes, amb les explicacions de com es pot aplicar el patr\u00f3 Observer en diversos \u00e0mbits i com el mecanisme d'events del navegador (com <code>EventTarget</code>) s'adapta a aquest patr\u00f3. Finalment, afegirem l'exemple de la pizzeria i identificarem els elements del patr\u00f3 Observer en aquest context.</p>"},{"location":"4.2.patrons_comportament/#ambits-daplicacio","title":"\u00c0mbits d'aplicaci\u00f3","text":"<p>Aquest patr\u00f3 \u00e9s molt vers\u00e0til i es pot utilitzar en una gran varietat de sistemes. Vegem alguns exemples:</p>"},{"location":"4.2.patrons_comportament/#sistema-de-notificacions-xat-o-missatgeria","title":"Sistema de Notificacions (Xat o Missatgeria)","text":"<p>Imagina un sistema de missatgeria en grup o un xat. En aquest cas, el servidor actua com a notificador i mant\u00e9 una llista de tots els clients (subscriptors). Quan es rep un missatge, el servidor notifica tots els clients del missatge enviat, actualitzant les seves interf\u00edcies d'usuari.</p> <ul> <li>Notificador: El servidor que rep i distribueix els missatges.</li> <li>Subscriptors: Els clients que estan connectats al servidor, cada un amb la seva pr\u00f2pia interf\u00edcie d'usuari per mostrar els missatges.</li> </ul> <p>Per implementar-ho:</p> <ul> <li>El servidor mant\u00e9 una llista de clients a qui notificar.</li> <li>Cada vegada que arriba un nou missatge, el servidor recorre la llista de clients i els notifica.</li> </ul> <p>Aquest sistema t\u00e9 una complexitat afegida:</p> <ul> <li>Els clients han de tenir informaci\u00f3 sobre el port de comunicaci\u00f3 (IP, port) per poder establir connexi\u00f3 amb el servidor i rebre els missatges de manera efectiva, i al mateix temps, el servidor ha de con\u00e9ixer les adreces IP i el port pel que s'estan connectant els clients.</li> <li>Aix\u00f2 pot implicar l'\u00fas de protocols de comunicaci\u00f3 com WebSockets o directament sockets a m\u00e9s baix nivell, per mantenir la connexi\u00f3 oberta entre el servidor i els clients.</li> </ul>"},{"location":"4.2.patrons_comportament/#carret-de-la-compra","title":"Carret de la compra","text":"<p>Un exemple m\u00e9s senzill \u00e9s el cas del carret de la compra: Posem com a exemple el nostre carret de l'aplicaci\u00f3 de la pizzeria. Imaginem que el carret t\u00e9 una llista de components subscrits (com el component que mostra el total de la comanda, els comptadors de cada producte o la pestanya que cont\u00e9 el contingut del carret).</p> <p>Quan el carret es modifica (per exemple, s'afegeix o elimina una pizza), el carret notifica a tots els components subscrits que l'estat ha canviat, i aquests actualitzen les seves interf\u00edcies en conseq\u00fc\u00e8ncia.</p> <p>Com s'aplica el patr\u00f3 Observer cqu\u00ed?</p> <ul> <li>El carret seria el notificador que mant\u00e9 una llista de components que volen rebre notificacions quan el contingut del carret canvie.</li> <li>Els components (per exemple, la vista del carret) seran subscriptors que escolten els canvis i actualitzen la seva visualitzaci\u00f3 quan el carret s'actualitza.</li> </ul> <p>\u00das d'<code>EventTarget</code> del navegador</p> <p>En el nostre exemple de la pizzeria, on estem fent \u00fas de la classe <code>EventTarget</code> del navegador, el mecanisme d'events ja implementa internament el patr\u00f3 Observer. El carret emet un esdeveniment quan el contingut canvia (per exemple, <code>\"carretActualitzat\"</code>) i els components subscrits (com el component de la vista) reaccionen a aquest esdeveniment actualitzant la seva visualitzaci\u00f3. Aquesta reacci\u00f3 la programem amb el m\u00e8tode <code>AddEventListener</code>.</p> <p>La gesti\u00f3 de la llista de subscripcions</p> <p>Quan utilitzem <code>EventTarget</code> per a gestionar esdeveniments (com el m\u00e8tode <code>addEventListener</code>), el navegador s'encarrega autom\u00e0ticament de mantenir la llista de subscriptors i de gestionar les notificacions quan l'esdeveniment \u00e9s em\u00e8s. En aquest cas, no hem de preocupar-nos per gestionar manualment la llista de subscripcions com fariem en una implementaci\u00f3 pr\u00f2pia del patr\u00f3 Observer. El navegador s'encarrega d'aquesta tasca internament.</p> <p>Identifica els diferents elements d'observer al carret</p> <p>Analitza el codi de l'aplicaci\u00f3 del carret per a la pizzeria, i identifica el seg\u00fcent:</p> <ul> <li>Quina \u00e9s la classe Notificadora? Com hem definit aquesta per poder enviar esdeveniments?</li> <li>Quines s\u00f3n les classes Subscriptores? Qu\u00e8 fa cadascuna d'elles (identifca el codi) per subscriure's a les notificacions?</li> <li>Quin m\u00e8tode utilitza la classe Notificadora que hereta de la classe pare per poder enviar notificacions?</li> <li>Observa l'estructura que es defineix a Refactoring Guru d'aquest patr\u00f3, i redefineix-la aplicant-la a caquest exemple del carret. Incorpora a la teua explicaci\u00f3 el diagrama de classes del patr\u00f3, adaptant-lo a aquest cas.</li> </ul>"},{"location":"4.3.patrons_estructurals/","title":"4.3.patrons estructurals","text":""},{"location":"4.3.patrons_estructurals/#patrons-estructurals","title":"Patrons Estructurals","text":"<p>Els patrons estructurals s'ocupen de com organitzar i compondre les classes i els objectes en sistemes complexos. Aquests patrons ajuden a simplificar l'estructura de classes i reutilitzar el codi mitjan\u00e7ant la creaci\u00f3 d'estructures m\u00e9s eficients i modulars. Els patrons estructurals s\u00f3n especialment \u00fatils quan tenim una arquitectura complexa o quan necessitem adaptar components ja existents.</p> <p>Els principals patrons estructurals que es comenten a Refactoring Guru s\u00f3n:</p> <ul> <li>Adapter</li> <li>Bridge</li> <li>Composite</li> <li>Decorator</li> <li>Facade</li> <li>Flyweight</li> <li>Proxy</li> </ul> <p>D'entre ells anem a centrar-nos en un parell de patorns, i veurem com es poden aplicar en situacions comunes. </p> <ul> <li>Adapter, que ens permetr\u00e0 que dues classes incompatibles treballen jnuntes, a trav\u00e9s d'una interf\u00edcie comuna,</li> <li>Decorator: Afegeix funcionalitat addicional a un objecte de manera flexible sense modificar la seva estructura.</li> </ul> <p>En aquest apartat ens centrarem en Adapter i Decorator, explicant com es poden aplicar en situacions comunes, com en l'exemple de tractament de fluxos a Java.</p>"},{"location":"4.3.patrons_estructurals/#patro-adapter","title":"Patr\u00f3 Adapter","text":"<p>El patr\u00f3 Adapter s'utilitza quan necessitem que dues classes que no s\u00f3n compatibles treballin conjuntament. Aquest patr\u00f3 crea una interf\u00edcie comuna entre les dues classes que tenen interf\u00edcies incompatibles, i adapta una classe perqu\u00e8 puga ser utilitzada per l\u2019altra.</p> <p>El patr\u00f3 Adapter \u00e9s una soluci\u00f3 ideal per als tipus de casos en qu\u00e8 necessitem adaptar representacions de dades en formats diferents. Per exemple, podriem crear un Adaptador que convertisca dades en format XML que obtinim d'una API a format JSON perqupe la nostra aplicaci\u00f3 treballe amb ells.</p> <p>Una altra situaci\u00f3 on ens trobem aquest patrons \u00e9s en el desenvolupament d'aplicaicons en Android, on per crear desplegables o llistes a partir d'informaci\u00f3 variada (un XML, un vector...), necessitem un Adaptador que agafe la informaci\u00f3 en el format original i l'adapte o genere els components corresponents (items del desplegable o la llista).</p>"},{"location":"4.3.patrons_estructurals/#exemple-practic-una-api-per-a-les-pizzes-en-xml","title":"Exemple pr\u00e0ctic: Una API per a les pizzes en XML","text":"<p>Imaginem que l'API de la pizzeria, en lloc de retornar-nos la informaci\u00f3 en JSON ho fa en XML. La nostra aplicaci\u00f3 espera rebre-les en JSON, pel que necessitarem  fer \u00fas d'aquest patr\u00f3 per adaptar l'XML a JSON.</p> <p>Per a aix\u00f2, farem \u00fas d'una URL que ens proporcione la informaci\u00f3 de les pizzes en format XML pur. </p> <p>Projecte d'exemple</p> <p>Deixarem l'exemple que anem treballant al repositori del projecte de la pizzeria (webapp_eljust_eat_pizza), concretament, dins la carpeta Sprint5_Adapters.</p> <p>El patr\u00f3 Repository</p> <p>El patr\u00f3 Respository no \u00e9s un patr\u00f3 de disseny com a tal (per aix\u00f2 no el voreu a Refactoring Guru), sin\u00f2 un patr\u00f3 arquitect\u00f2nic. Es tracta d'una abstracci\u00f3 per gestionar l'acc\u00e9s a les dades, que es fa servir per millorar l'escalabilitat i tindre un codi m\u00e9s mantenible.</p> <p>Comentem aquest patr\u00f3 repository perqu\u00e8 anem a introduir aquesta nova capa al nostre exemple de la pizzeria abans d'abordar el patr\u00f3 Adapter.</p> <p>La nostra aplicaci\u00f3, arquitect\u00f2nicament s'estructurava en les seg\u00fcents capes:</p> <ul> <li>components : amb els webcomponents, que s\u00f3n les vistes,</li> <li>libcomponents: amb la lliberria base de components,</li> <li>models: Amb els models del domini de l'aplicaci\u00f3 (pizzes, etc)</li> <li>services: Amb  la funcionalitat d'acc\u00e9s al servei</li> <li>state: Amb l'estat de l'aplicaci\u00f3 (classe carret)</li> </ul> <p>Al nostre codi, des del mateix main i les diferents vistes (webComponents), hem estat accedint directament a la capa de servei, suposant que aquesta ja ens retorna la representaci\u00f3 en JSON esperada.</p> <p>Si ara canviarem la forma de representaci\u00f3 de les dades, i haverem de modificar aquest servei per un altre, hauriem de modificar totes les refer\u00e8ncies a aquest servei que tinguerem pel codi.</p> <p>Per afegir un major nivell d'abstracci\u00f3 i desentendre'ns del servei que hi ha per baix, afegim una nova capa de repositori, que centraritzar\u00e0 la informaci\u00f3 que necessita la nostra aplicaci\u00f3, de manera independent a la capa de serveis.</p> <p>Inicialment, aquesta capa ser\u00e0 un pont entre la nostra aplicaci\u00f3 i la pr\u00f2pia capa de servei.</p> <p>Aquesta capa contindr\u00e0 una classe <code>PizzeriaRepository</code> amb el seg\u00fcent codi (observeu que t\u00e9 els mateixos m\u00e8todes que <code>PizzaService</code>, i que l'\u00fanic que fa \u00e9s retornar el que retornen estos):</p> <pre><code>import {PizzeriaService} from '../services/pizzeriaService.js';\n\nexport class PizzeriaRepository {\n    static async getAllPizzes() {\n        return PizzeriaService.getAllPizzes();\n    }\n\n    static async getAllEntrants() {\n        return PizzeriaService.getAllEntrants();\n    }\n\n    static async getAllDrinks() {\n        return PizzeriaService.getAllDrinks();\n    }\n\n    static async sendOrder(comanda) {\n        return PizzeriaService.sendOrder(comanda);\n\n    }\n}\n</code></pre> <p>Per utlitzar aquest repository, el que gem \u00e9s reemplazar totes les refer\u00e8ncies a <code>PizzeriaService</code> de la resta de codi per refer\u00e8ncies a <code>PizzeriaRepository</code></p> <p>Una vegada tenim clara l'explicaci\u00f3 anterior, anem a implementar un nou m\u00e8tode en el servei, que accedisca i ens retorne una representaci\u00f3 en XML de les dades.</p>"},{"location":"4.3.patrons_estructurals/#codi-dexemple","title":"Codi d'exemple:","text":"<ol> <li> <p>API que retorna dades en XML:    L'API de la pizzeria retorna una llista de pizzes en XML, i nosaltres volem convertir aquesta resposta a JSON per poder treballar amb ella.</p> </li> <li> <p>Adapter per convertir XML a JSON:    Crearem un adaptador per convertir l'XML a JSON.</p> </li> </ol>"},{"location":"4.3.patrons_estructurals/#implementacio-del-patro-adapter","title":"Implementaci\u00f3 del patr\u00f3 Adapter:","text":"<pre><code>import org.w3c.dom.*;\nimport javax.xml.parsers.*;\nimport java.io.*;\nimport org.json.JSONObject;\n\n// Classe base per representar una pizza (format JSON)\nclass Pizza {\n    private String nom;\n    private double preu;\n\n    public Pizza(String nom, double preu) {\n        this.nom = nom;\n        this.preu = preu;\n    }\n\n    public String getNom() {\n        return nom;\n    }\n\n    public double getPreu() {\n        return preu;\n    }\n}\n\n// Adaptador per convertir XML a JSON\ninterface PizzaAdapter {\n    JSONObject adaptarAJSON(String xml);\n}\n\nclass PizzaXMLAdapter implements PizzaAdapter {\n    @Override\n    public JSONObject adaptarAJSON(String xml) {\n        try {\n            // Convertir XML a JSONObject\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputStream inputStream = new ByteArrayInputStream(xml.getBytes());\n            Document doc = builder.parse(inputStream);\n            doc.getDocumentElement().normalize();\n\n            // Suposant que l'XML t\u00e9 una estructura similar a:\n            // &lt;pizza&gt;\n            //    &lt;nom&gt;Margarita&lt;/nom&gt;\n            //    &lt;preu&gt;8.5&lt;/preu&gt;\n            // &lt;/pizza&gt;\n            NodeList nodeList = doc.getElementsByTagName(\"pizza\");\n            JSONObject pizzaJSON = new JSONObject();\n            for (int i = 0; i &lt; nodeList.getLength(); i++) {\n                Node node = nodeList.item(i);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element element = (Element) node;\n                    String nom = element.getElementsByTagName(\"nom\").item(0).getTextContent();\n                    double preu = Double.parseDouble(element.getElementsByTagName(\"preu\").item(0).getTextContent());\n\n                    // Creem el JSON a partir de l'XML\n                    pizzaJSON.put(\"nom\", nom);\n                    pizzaJSON.put(\"preu\", preu);\n                }\n            }\n            return pizzaJSON;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n\n// Exemple d'\u00fas: convertim un XML a JSON\npublic class Main {\n    public static void main(String[] args) {\n        // Exemples d'XML que retorna l'API\n        String xml = \"&lt;pizza&gt;&lt;nom&gt;Margarita&lt;/nom&gt;&lt;preu&gt;8.5&lt;/preu&gt;&lt;/pizza&gt;\";\n\n        // Utilitzant el adaptador\n        PizzaAdapter adapter = new PizzaXMLAdapter();\n        JSONObject pizzaJSON = adapter.adaptarAJSON(xml);\n\n        // Mostra el resultat en JSON\n        System.out.println(pizzaJSON.toString());\n    }\n}\n</code></pre>"},{"location":"4.3.patrons_estructurals/#diagrama-uml-del-patro-adapter","title":"Diagrama UML del patr\u00f3 Adapter:","text":""},{"location":"4.3.patrons_estructurals/#explicacio-del-patro-adapter-en-aquest-exemple","title":"Explicaci\u00f3 del patr\u00f3 Adapter en aquest exemple:","text":"<ul> <li>PizzaAdapter: \u00c9s una interf\u00edcie que defineix el m\u00e8tode <code>adaptarAJSON()</code>, que \u00e9s el que permetr\u00e0 adaptar l'XML al format JSON.</li> <li>PizzaXMLAdapter: \u00c9s l'adaptador concret que converteix l'XML rebut de l'API a JSON. Aquest adaptador processa l'XML i crea un objecte <code>JSONObject</code> que l'aplicaci\u00f3 pot utilitzar.</li> <li>Pizza: Aquesta classe representa la pizza amb els atributs <code>nom</code> i <code>preu</code>. Tot i que no s'utilitza expl\u00edcitament a l'exemple, el JSON resultant de l'adaptador podria ser usat per crear inst\u00e0ncies de <code>Pizza</code>.</li> </ul>"},{"location":"4.3.patrons_estructurals/#com-funciona-ladaptador","title":"Com funciona l'adaptador?","text":"<ul> <li>L'API original retorna les dades de les pizzes en format XML, per\u00f2 la nostra aplicaci\u00f3 espera un objecte en format JSON.</li> <li>El PizzaXMLAdapter adapta les dades XML a una estructura JSON, permetent que la nostra aplicaci\u00f3 treballi amb el format esperat.</li> <li>El codi fa servir el m\u00e8tode <code>adapatarAJSON</code> per convertir l'XML en un <code>JSONObject</code> que cont\u00e9 la informaci\u00f3 de la pizza.</li> </ul>"},{"location":"4.3.patrons_estructurals/#conclusio","title":"Conclusi\u00f3:","text":"<p>El patr\u00f3 Adapter \u00e9s molt \u00fatil en situacions on necessitem convertir entre formats incompatibles, com en aquest cas, convertir dades d'una API XML a un format que la nostra aplicaci\u00f3 pot manejar (JSON). El patr\u00f3 permet que la nostra aplicaci\u00f3 sigui flexible i adaptable a canvis de format sense modificar el codi existent.</p> <p>T'agrada aquest enfocament per al patr\u00f3 Adapter? Vols afegir m\u00e9s detalls o ajustar alguna cosa en l'exemple? \ud83d\ude0a</p>"},{"location":"4.3.patrons_estructurals/#2-patro-decorator","title":"2. Patr\u00f3 Decorator","text":"<p>El patr\u00f3 Decorator s\u2019utilitza per afegir funcionalitat a un objecte de manera din\u00e0mica. El principal avantatge d\u2019aquest patr\u00f3 \u00e9s que ens permet modificar el comportament d\u2019un objecte sense modificar la seva classe base, cosa que el fa extremadament flexible.</p>"},{"location":"4.3.patrons_estructurals/#exemple-de-codi-decorator","title":"Exemple de codi (Decorator):","text":"<p>Un exemple cl\u00e0ssic del patr\u00f3 Decorator es troba en el tractament de fluxos de dades a Java. Les classes <code>InputStream</code> i <code>OutputStream</code> utilitzen decoradors per afegir funcionalitat extra, com la lectura de dades en un format determinat (per exemple, llegir dades comprimides o encriptades).</p> <pre><code>import java.io.*;\n\n// Component base\nclass Coffee {\n    public String serve() {\n        return \"Caf\u00e8\";\n    }\n}\n\n// Decorador base\nabstract class CoffeeDecorator extends Coffee {\n    protected Coffee decoratedCoffee;\n\n    public CoffeeDecorator(Coffee coffee) {\n        this.decoratedCoffee = coffee;\n    }\n\n    public String serve() {\n        return decoratedCoffee.serve();\n    }\n}\n\n// Decorador concret 1\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String serve() {\n        return decoratedCoffee.serve() + \" amb llet\";\n    }\n}\n\n// Decorador concret 2\nclass SugarDecorator extends CoffeeDecorator {\n    public SugarDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String serve() {\n        return decoratedCoffee.serve() + \" amb sucre\";\n    }\n}\n\n// Exemple d'\u00fas\npublic class Main {\n    public static void main(String[] args) {\n        Coffee coffee = new Coffee();\n        System.out.println(coffee.serve()); // Caf\u00e8\n\n        coffee = new MilkDecorator(coffee);\n        System.out.println(coffee.serve()); // Caf\u00e8 amb llet\n\n        coffee = new SugarDecorator(coffee);\n        System.out.println(coffee.serve()); // Caf\u00e8 amb llet amb sucre\n    }\n}\n</code></pre>"},{"location":"4.3.patrons_estructurals/#explicacio-del-patro-decorator","title":"Explicaci\u00f3 del patr\u00f3 Decorator:","text":"<ul> <li>Coffee \u00e9s el component base, que serveix un caf\u00e8 senzill.</li> <li>CoffeeDecorator \u00e9s una classe abstracta que permet afegir funcionalitat extra a qualsevol objecte Coffee de manera din\u00e0mica.</li> <li>MilkDecorator i SugarDecorator s\u00f3n decoradors concrets que afegeixen la llet i el sucre, respectivament.</li> <li>El comportament de serve() es modifica din\u00e0micament sense haver de modificar el comportament original de la classe Coffee.</li> </ul>"},{"location":"4.3.patrons_estructurals/#diagrama-uml-del-patro-decorator","title":"Diagrama UML del patr\u00f3 Decorator:","text":""},{"location":"4.3.patrons_estructurals/#conclusio_1","title":"Conclusi\u00f3:","text":"<p>Els patrons estructurals com Adapter i Decorator s\u00f3n extremadament \u00fatils per millorar la flexibilitat del codi i permetre la modificaci\u00f3 de comportaments sense tocar el codi original.</p> <ul> <li>Adapter \u00e9s ideal quan tens classes incompatibles i necessites adaptar-les per poder treballar amb elles de manera conjunta.</li> <li>Decorator \u00e9s perfecte quan necessites afegir funcionalitats a un objecte sense canviar la seva classe base, com en el cas de la manipulaci\u00f3 de fluxos de dades a Java.</li> </ul> <p>Qu\u00e8 et sembla aquesta explicaci\u00f3? Vols que aprofundim m\u00e9s en algun d'aquests patrons o que modifiquem algun detall? \ud83d\ude0a</p>"}]}