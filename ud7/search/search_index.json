{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inici","text":""},{"location":"#resultats-daprenentatge","title":"Resultats d'aprenentatge","text":"<ul> <li>RA3. Verifica el funcionament de programes dissenyant i realitzant proves.</li> </ul>"},{"location":"#criteris-davaluacio","title":"Criteris d'avaluaci\u00f3","text":"<ul> <li>RA3.a) S'han identificat els diferents tipus de proves.</li> <li>RA3.b) S'han definit casos de prova.</li> <li>RA3.c) S'han identificat les eines de depuraci\u00f3 i prova d'aplicacions oferides per l'entorn de desenvolupament.</li> <li>RA3.d) S'han utilitzat eines de depuraci\u00f3 per a definir punts de ruptura i seguiment.</li> <li>RA3.e) S'han utilitzat les eines de depuraci\u00f3 per a examinar i modificar el comportament d'un programa en temps d'execuci\u00f3.</li> <li>RA3.f) S'han efectuat proves unit\u00e0ries de classes i funcions.</li> <li>RA3.g) S'han implementat proves autom\u00e0tiques.</li> <li>RA3.h) S'han documentat les incid\u00e8ncies detectades.</li> <li>RA3.i) S'han utilitzat dobles de prova per a a\u00efllar els components durant les proves.</li> </ul> <p>Comencem!</p>"},{"location":"jest/","title":"4. Jest","text":""},{"location":"jest/#proves-amb-javascript-jest","title":"Proves amb Javascript: Jest","text":"<p>Jest \u00e9s un framework de proves per a JavaScript desenvolupat per Facebook. \u00c9s especialment popular en projectes basats en React, per\u00f2 tamb\u00e9 es pot utilitzar per provar aplicacions de Node.js o qualsevol codi JavaScript.</p> <p>Jest \u00e9s molt f\u00e0cil d'utilitzar, permet escriure proves unit\u00e0ries, de m\u00f2duls i d'integraci\u00f3 amb mocks, spies i altres t\u00e8cniques per a\u00efllar les depend\u00e8ncies durant les proves.</p> <p>Per qu\u00e8 utilitzar Jest?</p> <ul> <li>Rapidesa i facilitat de configuraci\u00f3.</li> <li>Suporta tant frontend com backend.</li> <li>Mocking i spies per a provar codi amb depend\u00e8ncies externes (per exemple, API, base de dades).</li> <li>Instantaneous HMR (Hot Module Replacement) durant el desenvolupament.</li> <li>Integraci\u00f3 senzilla amb eines com React Testing Library, Supertest, etc.</li> <li>Cobertura de codi integrada per mesurar la qualitat de les proves.</li> </ul>"},{"location":"jest/#plantejament-general-del-projecte","title":"Plantejament general del projecte","text":"<p>Anem a crear un projecte que conste d'un backend b\u00e0sic en NodeJS i d'un frontend, basat en webComponents, de manera que provem tant el servidor com els components.</p> <p>Per a ambd\u00f3s casos farem \u00fas de Jest, aprofitant les seues capacitats de mocking i testing per a Javascript pur.</p> <p>Actualitzant node i npm</p> <p>Anem a treballara amb les \u00faltimes versions de node i npm des de Linux.</p> <p>Per a aix\u00f2 farem \u00fas de l'eina <code>nvm</code> (Node Version Manager).</p> <p>Per descarregar aquesta eina ho farem des del seu script d'instal\u00b7laci\u00f3, que descarregarem amb <code>curl -o-</code> o b\u00e9 amb <code>wget -qO-</code> i executar-lo. Ho podem fer en una ordre amb:</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash\n</code></pre> <p>Aquest script ja descarrega, instal\u00b7la i configura nvm, pel que si obrim una nova terminal ja la tindrem disponible.</p> <p>Ara podem veure la versi\u00f3 de nvm instal\u00b7lada amb:</p> <pre><code>$ nvm --version\n0.40.3\n</code></pre> <p>Ara amb <code>lvm ls</code> podem veure la versi\u00f3 del sistema i amb <code>lvm ls-remote</code> les versions disponibles.</p> <p>Per tal d'instal\u00b7lar la \u00faltima versi\u00f3, farem:</p> <pre><code>nvm install 22.15.0\n</code></pre> <p>Comproveu amb <code>node -v</code> que hem instal\u00b7lat aquesta versi\u00f3.</p> <p>I per instal\u00b7lar la \u00faltima versi\u00f3 de <code>npm</code>:</p> <pre><code>nvm install-latest-npm \n</code></pre> <p>Podem comprovar amb <code>npm -v</code> que tenim la versi\u00f3 11.0.3.</p>"},{"location":"jest/#configuracio-basica-de-jest-en-un-projecte","title":"Configuraci\u00f3 b\u00e0sica de Jest en un projecte","text":"<ol> <li>Crear i inicialitzar el projecte:</li> </ol> <pre><code>$ mkdir projecte-test\n$ cd projecte-test\n$  npm init -y\n</code></pre> <p>ES Module!</p> <p>Recordeu-vos-en d'editar la configuraci\u00f3 del projecte i definir-lo com un ES-Module, no com commonJS!</p> <ol> <li>Instal\u00b7laci\u00f3 de les depend\u00e8ncies:</li> </ol> <pre><code>$ npm install jest supertest babel-jest @babel/preset-env jsdom\n$ npm install --save-dev jest-environment-jsdom\n</code></pre> <ul> <li><code>jest</code>: \u00e9s el framework de proves.</li> <li><code>supertest</code>: Ens serveix per fer proves en nodejs.</li> <li>Les llibrer\u00edes <code>babel-jest</code> i <code>@babel/preset-env</code> ens serviran per fer compatible jest amb els m\u00f2duls ESModules, ja que no ho s\u00f3n de manera predeterminada.</li> <li><code>jsdom</code> \u00e9s un entorn de test per simular un navegador virtual.</li> <li><code>jest-environment-jsdom</code> \u00e9s una llibreria de desenvolupament per treballar un entorn JSDOM des de Jest.</li> </ul> <p>Jest es configura autom\u00e0ticament amb una configuraci\u00f3 b\u00e0sica i funcional. Si volem personalitzar la configuraci\u00f3, podem afegir un fitxer de configuraci\u00f3, tal i com s'indica a la documentaci\u00f3.</p> <p>Al nostre cas, anem a afegir un fitxer <code>babel.config.js</code> amb el seg\u00fcent contingut:</p> <pre><code>export const presets = [\n    '@babel/preset-env', // Transforma codi modern (ES6+) a codi compatible amb Node.js\n];\n</code></pre> <p>I el fitxer <code>jest.config.js</code> amb:</p> <pre><code>export const transform = {\n    '^.+\\\\.js$': 'babel-jest', // Transforma els fitxers .js amb Babel\n};\nexport const testEnvironment = 'node';\n</code></pre> <p>Amb el primer script, configurem l'eina Babel per transformar el codi que utilitza ESModules en codi compatible amb Node.js. El segon script, Jest far\u00e0 servir Babel per transformar tots els fitxers Javascript abans d'executar les proves, i defineix l'entorn de test amb node.</p> <p>Fet aix\u00f2, editarem la configuraci\u00f3, ens assegurarem que estiga tot correcte, i modificarem els scripts amb:</p> <pre><code>  \"scripts\": {\n    \"test\": \"jest\"\n  },\n</code></pre> <p>Per utilitzar Jest quan fem un <code>npm run test</code> (o simplement <code>npm test</code>).</p>"},{"location":"jest/#codi-del-backend","title":"Codi del backend","text":"<p>Crearem un fitxer <code>backend/server.js</code> amb el seg\u00fcent contingut:</p> <pre><code>import { createServer } from 'http';\n\n// Creem un servidor HTTP b\u00e0sic\nconst server = createServer((req, res) =&gt; {\n  if (req.method === 'GET' &amp;&amp; req.url === '/greeting') {\n    res.statusCode = 200;\n    res.setHeader('Content-Type', 'application/json');\n    res.end(JSON.stringify({ message: 'Hello from Node.js!' }));\n  } else {\n    res.statusCode = 404;\n    res.end();\n  }\n});\n\nserver.listen(3000, () =&gt; {\n  console.log('Server is running on http://localhost:3000');\n});\n\nexport default server; \n</code></pre> <p>Aquest codi crea un servidor HTTP molt b\u00e0sic (sense necessitat d'Express), fent \u00fas de la llibreria http.</p> <p>El servidor est\u00e0 configurat per respondre a peticions de tipus GET i a l'url '/greeting'. En aquest cas, retornar\u00e0 un codi 200 i un JSON amb el contingut <code>{ message: 'Hello from Node.js!' }</code>.</p> <p>Obseveu que a la \u00faltima l\u00ednia, exportem el component <code>server</code>.</p>"},{"location":"jest/#configurant-les-proves-per-al-backend","title":"Configurant les proves per al backend","text":"<p>Ara, utilitzarem Jest i Supertest per provar l'API de Node.js. Supertest ens permet fer peticions HTTP al servidor i verificar les respostes de manera senzilla.</p> <p>Generem el seg\u00fcent fitxer <code>backend/server.test.js</code>:</p> <pre><code>import request from 'supertest';\nimport server from './server.js';  // Importem el servidor\n\n\ndescribe('GET /greeting', () =&gt; {\n  it('Deuria retornar un missatge de benvinguda', async () =&gt; {\n    const response = await request(server).get('/greeting');\n    expect(response.status).toBe(200);\n    expect(response.body.message).toBe('Hello from Node.js!');\n  });\n\n  it('Deuria retornar un error 404 de ruta no v\u00e0lida', async () =&gt; {\n    const response = await request(server).get('/invalid-route');\n    expect(response.status).toBe(404);\n  });\n});\n</code></pre> <ul> <li>Amb <code>request(server).get('/greeting')</code> simulem una petici\u00f3 HTTP de tipus GET al servidor a la ruta /greeting.</li> <li><code>expect(response.status).toBe(200)</code>: Comprova que el codi de resposta siga 200 OK.</li> <li><code>expect(response.body.message).toBe('Hola des de Node.js!')</code>: Verifica que el missatge retornat siga el correcte.</li> <li>Tamb\u00e9 es comprova que una ruta no v\u00e0lida retorne un codi 404.</li> </ul> <p>Amb tot aix\u00f2, realitzarem la prova amb <code>npm test</code>:</p> <pre><code>$ npm test\n\n&gt; projecte-test@1.0.0 test\n&gt; jest\n\n  console.log\n    Server is running on http://localhost:3000\n\n      at Server.log (backend/server.js:16:11)\n\n PASS  backend/server.test.js\n  GET /greeting\n    \u2713 Deuria retornar un missatge de benvinguda (49 ms)\n    \u2713 Deuria retornar un error 404 de ruta no v\u00e0lida (4 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        0.658 s\nRan all test suites.\n</code></pre> <p>Com veiem, ha llan\u00e7at tots els tests i aquests han estat exitosos. Podeu provar a modificar el missatge i veure'n l'efecte.</p>"},{"location":"junit/","title":"2. Junit Jupiter","text":""},{"location":"junit/#practica-amb-junit-jupiter","title":"Pr\u00e0ctica amb JUnit Jupiter","text":"<p>JUnit Jupiter \u00e9s un framework de testeig per a Java. Quan creem un projecte amb Gradle, per exemple, tenim la possibilitat ja d'incorporar el framwork al projecte.</p> <p>Anem a veure com fer-ho.</p>"},{"location":"junit/#pas-1-configuracio-de-lentorn","title":"Pas 1. Configuraci\u00f3 de l'entorn","text":"<ol> <li>En el teu directori de treball, crea una carpeta per a un projecte Gradle nou (per exemple <code>calculadora</code>).</li> <li>Crea un nou projecte amb <code>gradle init</code>, amb les seg\u00fcents caracter\u00edstiques concretes:<ul> <li>Projecte de tipus aplicaci\u00f3</li> <li>Llenguatge Java 21</li> <li>Estructur de projecte \u00fanic (Single application Project)</li> <li>DSL Groovy</li> <li>Framework de testing: JUnit Jupiter</li> <li>Sense incorporar APIs i comportament experimental</li> </ul> </li> <li>Edita el projete amb VSCode, i comprova el seg\u00fcent<ul> <li> <p>Consulta el fitxer <code>app/build.gradle</code> i verifica que tens les depend\u00e8ncies:</p> <pre><code>// Use JUnit Jupiter for testing.\n    testImplementation libs.junit.jupiter\n    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'\n</code></pre> </li> </ul> </li> </ol> <p><code>testImplementation</code>i <code>testRuntimeOnly</code></p> <ul> <li><code>testImplementation</code>: especifica que JUnit Jupiter ser\u00e0 utilitzada en temps de compilaci\u00f3 per a les proves. \u00c9s a dir, s'inclou en el proc\u00e9s de compilaci\u00f3 i es pot utilitzar per escriure les proves dins del projecte.</li> <li> <p><code>testRuntimeOnly</code>: Aquesta depend\u00e8ncia especifica que el JUnit Platform Launcher nom\u00e9s es necessita en temps d'execuci\u00f3, no en compilaci\u00f3. \u00c9s a dir, aquest component nom\u00e9s s'utilitza per executar les proves (no per escriure-les), i no \u00e9s necessari per a la compilaci\u00f3 del codi.</p> </li> <li> <p>Comprova que tamb\u00e9 apareix la tasca <code>test</code>:</p> </li> </ul> <pre><code>tasks.named('test') {\n    // Use JUnit Platform for unit tests.\n    useJUnitPlatform()\n}\n</code></pre> <p>Amb la qual configurem l'execuci\u00f3 de les proves unit\u00e0ries perqu\u00e8 utilitzin el JUnit Platform. Aquesta ser\u00e0 doncs la tasca responsable d'executar les proves. JUnit Platform \u00e9s l'entorn que gestiona l'execuci\u00f3 de les proves, el qual permet l'\u00fas de funcionalitats modernes de JUnit (com anotacions tipus @Test, etc.)</p>"},{"location":"junit/#pas-2-creacio-del-codi-i-les-proves","title":"Pas 2. Creaci\u00f3 del codi i les proves","text":"<p>Com veur\u00e0s al <code>build.gradle</code> tenim definida la classe principal de l'aplicaci\u00f3 <code>mainClass = 'org.example.App'</code>. Aix\u00f2 implica que tenim definit el paquet <code>org.example</code> i l'estrucutra de carpetes seg\u00fcent:</p> <pre><code>app/src\n    \u251c\u2500\u2500 main\n    \u2502   \u251c\u2500\u2500 java\n    \u2502   \u2502   \u2514\u2500\u2500 org\n    \u2502   \u2502       \u2514\u2500\u2500 example\n    \u2502   \u2502           \u2514\u2500\u2500 App.java\n    \u2502   \u2514\u2500\u2500 resources\n    \u2514\u2500\u2500 test\n        \u251c\u2500\u2500 java\n        \u2502   \u2514\u2500\u2500 org\n        \u2502       \u2514\u2500\u2500 example\n        \u2502           \u2514\u2500\u2500 AppTest.java\n        \u2514\u2500\u2500 resources\n</code></pre> <p>Si llancem el projecte amb <code>gradle run</code> ontindrem un missatge <code>Hello World</code>. Observem el codi <code>App.java</code>:</p> <pre><code>package org.example;\n\npublic class App {\n    public String getGreeting() {\n        return \"Hello World!\";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new App().getGreeting());\n    }\n}\n</code></pre> <p>Com veiem, el main crea una inst\u00e0ncia de la classe App i fa \u00fas del m\u00e8tode <code>getGreeting</code> d'aquesta, el qual mostra el missatge d'Hola m\u00f3n.</p> <p>Veiem ara el fitxer <code>AppTest.java</code> generat autom\u00e0ticament:</p> <pre><code>/*\n * This source file was generated by the Gradle 'init' task\n */\npackage org.example;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass AppTest {\n    @Test void appHasAGreeting() {\n        App classUnderTest = new App();\n        assertNotNull(classUnderTest.getGreeting(), \"app should have a greeting\");\n    }\n}\n</code></pre> <p>Com veiem, aquest codi fa dos imports de Junit Jupiter:</p> <ul> <li><code>import org.junit.jupiter.api.Test;</code>, amb la qual importa l'anotaci\u00f3 <code>@Test</code> de JUnit Jupiter, amb la qual marquem un m\u00e8tode com a m\u00e8tode de prova.</li> <li><code>import static org.junit.jupiter.api.Assertions.*;</code>: amb la qual importem les asercions de JUnit, que es poden utilitzar per verificar que el resultat d'una prova siga correcte (com <code>assertNotNull</code>). Una asserci\u00f3 ser\u00e0 doncs l'expressi\u00f3 que utilitzarem per validar els resultats.</li> </ul> <p>Aleshores, com veiem, el m\u00e8tode <code>appHasAGreeting</code> est\u00e0 marcat amb l'anotaci\u00f3 <code>@Test</code>, indicant que \u00e9s una prova que s'ha d'executar. Aquesta ser\u00e0 una prova unit\u00e0ria, ja que provem una classe concreta. </p> <p>Dins aquest m\u00e8tode, creem una inst\u00e0ncia (<code>classUnderTest</code>) de la nostra classe <code>App</code> i fem \u00fas de l'asserci\u00f3 <code>assertNotNull(classUnderTest.getGreeting())</code>, amb la qual es comprova que el valor retornat per <code>getGreeting()</code> no siga nul. Si el missatge existeix, la prova passar\u00e0. Si no, fallar\u00e0, mostrant el missatge <code>\"app should have a greeting\"</code>.</p> <p>Per tal d'executar aqeusta prova, nom\u00e9s caldr\u00e0 executar la tasca test amb <code>gradle test</code>.</p> <p>Quan ho fem, GRadle buscar\u00e0 la classe amb l'anotaci\u00f3 <code>@Test</code> i executar\u00e0 els seus m\u00e8todes corresponents. Si la prova passa, el resultat ser\u00e0 semblant el seg\u00fcent:</p> <pre><code>BUILD SUCCESSFUL in 1s\n1 actionable task: 1 executed\n</code></pre> <p>Com veiem, no mostra res, i aix\u00f2 \u00e9s b\u00f2. Si ara modifiquem el codi de la funci\u00f3 <code>getGreeting()</code> per a que retorne <code>null</code> en lloc de <code>\"Hello World!\"</code>, tindrem una excepci\u00f3 com a resultat:</p> <pre><code>&gt; Task :app:test FAILED\n\nAppTest &gt; appHasAGreeting() FAILED\n    org.opentest4j.AssertionFailedError at AppTest.java:12\n\n1 test completed, 1 failed\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task ':app:test'.\n&gt; There were failing tests. See the report at: file:///.../calculadora/app/build/reports/tests/test/index.html\n\n* Try:\n&gt; Run with --scan to get full insights.\n\nBUILD FAILED in 2s\n3 actionable tasks: 2 executed, 1 up-to-date\n</code></pre> <p>Com veiem, en la carpeta build/reports/tests/test tenim una p\u00e0gina web amb els resultats del test. Fes-li una ullada!</p>"},{"location":"junit/#modificacio-del-codi","title":"Modificaci\u00f3 del codi","text":"<p>Una vegada hem vist les proves generades autom\u00e0ticament, anem a modificar el projecte. En primer lloc, canviarem l'estructura de directoris i els packages a <code>com.ieseljust.edd</code>, i crearem una nova classe <code>Calculadora.java</code> en els fonts i <code>CalculadoraTest.java</code> en els tests. Ens quedar\u00e0:</p> <pre><code>app/src\n\u251c\u2500\u2500 main\n\u2502   \u251c\u2500\u2500 java\n\u2502   \u2502   \u2514\u2500\u2500 com\n\u2502   \u2502       \u2514\u2500\u2500 ieseljust\n\u2502   \u2502           \u2514\u2500\u2500 edd\n\u2502   \u2502               \u251c\u2500\u2500 App.java\n\u2502   \u2502               \u2514\u2500\u2500 Calculadora.java\n\u2502   \u2514\u2500\u2500 resources\n\u2514\u2500\u2500 test\n    \u251c\u2500\u2500 java\n    \u2502   \u2514\u2500\u2500 com\n    \u2502       \u2514\u2500\u2500 ieseljust\n    \u2502           \u2514\u2500\u2500 edd\n    \u2502               \u251c\u2500\u2500 AppTest.java\n    \u2502               \u2514\u2500\u2500 CalculadoraTest.java\n    \u2514\u2500\u2500 resources\n</code></pre> <p>Com podeu veure, no hem eliminat la classe App ni AppTest, encara que s\u00ed que caldr\u00e0 canviar el nom dels packages a la nova estructura.</p> <p>El codi de la classe Calculadora ser\u00e0 el seg\u00fcent:</p> <pre><code>package com.ieseljust.edd;\n\npublic class Calculadora {\n    public int suma(int a, int b) {\n        return a + b;\n    }\n\n    public int resta(int a, int b){\n        return a-b;\n    }\n}\n</code></pre> <p>I CalculadoraTest.java ser\u00e0:</p> <pre><code>package com.ieseljust.edd;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculadoraTest {\n\n    private Calculadora calculadora;\n\n    @BeforeEach\n    public void setUp() {\n        calculadora = new Calculadora();\n    }\n\n    @Test\n    public void testSuma() {\n        int resultat = calculadora.suma(3, 4);\n        assertEquals(7, resultat, \"La suma ha de ser correcta\");\n    }\n\n    @Test\n    public void testResta() {\n        int resultat = calculadora.resta(7, 4);\n        assertEquals(3, resultat, \"La resta ha de ser correcta\");\n    }\n}\n</code></pre> <p>Com veiem, hem definit un parell de funcions de test: <code>testSuma</code> i <code>testResta</code>. Mirem abans alguns detalls m\u00e9s:</p> <ul> <li>L'anotaci\u00f3 <code>@BeforeEach</code> marca un m\u00e8tide per a que s'execute abans de cada prova, i s'usa per configurar l'entorn de proves; \u00e9s a dir, crear una inst\u00e0ncia <code>calculadora</code>.</li> <li>Amb <code>@Test</code> ja hem vist que s'indiquen els m\u00e8todes de prova. </li> <li><code>assertEquals</code> \u00e9s l'asserci\u00f3 que comprova si el valor esperat \u00e9s igual al valor obtingut.</li> </ul> <p>Ara pots tornar a llan\u00e7ar el test i explorar els diferents resultats obtinguts. Prova a introduir algun error en els c\u00e0lculs i comprova que d\u00f3na error.</p> <p>Documentaci\u00f3 addicional</p> <ul> <li>Documentaci\u00f3 oficial de Junit Jupiter</li> </ul>"},{"location":"mockito/","title":"3. Dobles de prova: Mockito","text":""},{"location":"mockito/#dobles-de-prova-amb-mockito","title":"Dobles de prova amb Mockito","text":"<p>Mockito \u00e9s una biblioteca popular de Java utilitzada per crear dobles de prova (mocks) de manera senzilla i eficient. Els dobles de prova, s'utilitzen en les proves per a\u00efllar el codi que es vol provar de les depend\u00e8ncies externes (com bases de dades, serveis web, altres components del sistema, etc.).</p>"},{"location":"mockito/#que-es-un-mock-en-el-context-de-les-proves","title":"Qu\u00e8 \u00e9s un mock en el context de les proves?","text":"<p>Un mock \u00e9s un tipus de doble de prova que substitueix una depend\u00e8ncia real per una versi\u00f3 controlada, creada expl\u00edcitament per comprovar que les interaccions entre el codi que estem provant i les seves depend\u00e8ncies es produeixin de manera correcta.</p> <p>Els mocks s\u00f3n \u00fatils quan volem verificar que certes m\u00e8todes es criden amb els arguments correctes, o quan volem evitar que certes depend\u00e8ncies reals (com connexions de xarxa o de base de dades) facen l'execuci\u00f3 de les proves m\u00e9s lenta o complexa.</p>"},{"location":"mockito/#com-funciona-mockito","title":"Com funciona Mockito?","text":"<p>Mockito permet crear mocks de classes o interf\u00edcies, establir el comportament esperat dels m\u00e8todes (per exemple, qu\u00e8 han de retornar quan se'ls cride) i verificar les interaccions despr\u00e9s de l'execuci\u00f3 de la prova.</p>"},{"location":"mockito/#aplicacio-a-la-calculadora","title":"Aplicaci\u00f3 a la calculadora","text":"<p>Veiem com creariem una doble prova per a la calculadora.</p> <p>Abans que res, haurem d'incorporar la llibreria Mockito al nostre projecte.</p> <p>Per a aix\u00f2, al fitxer <code>app/build.gralde</code> afegim a les depend\u00e8ncies:</p> <pre><code>repositories {\n    // Use Maven Central for resolving dependencies.\n    mavenCentral()\n}\n\ndependencies {\n  ...\n    // https://mvnrepository.com/artifact/org.mockito/mockito-core\n    testImplementation(\"org.mockito:mockito-core:5.17.0\")\n}\n</code></pre> <p>Una vegada guardat el fixer, haurem de sincronitzar el projecte amb Gradle.</p> <p>Una vegada sincronitzat, creem la classe <code>CalculadoraTestService</code>:</p> <pre><code>package com.ieseljust.edd;\n\nimport static org.mockito.Mockito.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculadoraServiceTest {\n\n    @Test\n    public void testService() {\n        Calculadora mockCalculadora = mock(Calculadora.class);\n        when(mockCalculadora.sumar(3, 4)).thenReturn(7);\n\n        assertEquals(7, mockCalculadora.sumar(3, 4));\n    }\n}\n</code></pre> <p>Documentaci\u00f3 addicional</p> <ul> <li>Lloc web de Mockito</li> <li>Pruebas unitarias con Mockito en Java</li> <li>Aprende a crear pruebas unitarias con JUnit y Mockito en 15 minutos</li> <li>Curs OpenWebinars: Testing en Java con JUnit 5</li> <li>Article JaCoCo y la cobertura de pruebas en el c\u00f3digo</li> </ul>"},{"location":"proves/","title":"1. Introducci\u00f3","text":""},{"location":"proves/#1-prova-de-programari","title":"1. Prova de programari","text":""},{"location":"proves/#que-son-les-proves-i-per-que-son-importants","title":"Qu\u00e8 s\u00f3n les proves i per qu\u00e8 s\u00f3n importants?","text":"<p>Les proves de programari s\u00f3n activitats dissenyades per verificar que un sistema compleix amb els requisits establerts. Permeten detectar errors en el codi, millorar la qualitat del programari i garantir que els canvis realitzats no introdueixin nous errors (proves de regressi\u00f3).</p>"},{"location":"proves/#quins-tipus-de-proves-hi-ha","title":"Quins tipus de proves hi ha?","text":"<ul> <li> <p>Proves unit\u00e0ries: Es verifiquen xicotetes unitats del codi (com funcions o m\u00e8todes) de manera a\u00efllada. Cada unitat s'executa de forma independent per assegurar-se que fa el que ha de fer.</p> </li> <li> <p>Proves d'integraci\u00f3: Verifiquen la interacci\u00f3 entre diferents m\u00f2duls o components d'un sistema.</p> </li> <li> <p>Proves de sistema: Avaluen tot el sistema de programari com un conjunt, verificant si compleix amb els requisits funcionals i no funcionals.</p> </li> <li> <p>Proves de regressi\u00f3: S\u00f3n un tipus de prova per assegurar-se que les modificacions al codi no han trencat funcionalitats que pr\u00e8viament funcionaven.</p> </li> </ul>"},{"location":"proves/#de-quines-estrategies-disposem-per-a-la-realizacio-de-proves","title":"De quines estrat\u00e8gies disposem per a la realizaci\u00f3 de proves?","text":"<ul> <li> <p>Proves de caixa blanca (White-box Testing): S\u00f3n proves on es coneix l'interior del codi. Es dissenyen casos de prova basats en l'arquitectura del codi font i l'estructura del programa.</p> </li> <li> <p>Proves de Caixa negra (Black-box Testing): Ac\u00ed, les proves es basen en les especificacions externes del sistema. Qui fa el test no coneix l'interior del codi i nom\u00e9s verifica que els comportaments siguen correctes en funci\u00f3 de les entrades i eixides.</p> </li> </ul>"},{"location":"proves/#mesures-de-qualitat-del-codi","title":"Mesures de Qualitat del Codi","text":"<p>Hi ha diverses formes de con\u00e9ixer la qualitat de les proves de codi:</p> <ul> <li> <p>Cobertura de codi: Mesura quantes l\u00ednies del codi s\u00f3n cobertes per les proves. Una alta cobertura implica que les proves estan verificant gran part del sistema.</p> </li> <li> <p>Complexitat ciclom\u00e0tica: Medeix la complexitat del codi a partir de la quantitat de camins independents. Un valor elevat pot indicar que el codi \u00e9s dif\u00edcil de mantenir i provar.</p> </li> </ul>"}]}